{"ast":null,"code":"/**\r\n * DevExtreme (esm/ui/scheduler/recurrence.js)\r\n * Version: 23.1.5\r\n * Build date: Wed Aug 30 2023\r\n *\r\n * Copyright (c) 2012 - 2023 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport errors from \"../../core/errors\";\nimport { each } from \"../../core/utils/iterator\";\nimport { RRule, RRuleSet } from \"rrule\";\nimport dateUtils from \"../../core/utils/date\";\nimport timeZoneUtils from \"./utils.timeZone\";\nvar toMs = dateUtils.dateToMilliseconds;\nvar ruleNames = [\"freq\", \"interval\", \"byday\", \"byweekno\", \"byyearday\", \"bymonth\", \"bymonthday\", \"count\", \"until\", \"byhour\", \"byminute\", \"bysecond\", \"bysetpos\", \"wkst\"];\nvar freqNames = [\"DAILY\", \"WEEKLY\", \"MONTHLY\", \"YEARLY\", \"SECONDLY\", \"MINUTELY\", \"HOURLY\"];\nvar days = {\n  SU: 0,\n  MO: 1,\n  TU: 2,\n  WE: 3,\n  TH: 4,\n  FR: 5,\n  SA: 6\n};\nvar loggedWarnings = [];\nvar MS_IN_HOUR = 36e5;\nvar MS_IN_DAY = 24 * MS_IN_HOUR;\nvar recurrence = null;\nexport function getRecurrenceProcessor() {\n  if (!recurrence) {\n    recurrence = new RecurrenceProcessor();\n  }\n  return recurrence;\n}\nclass RecurrenceProcessor {\n  constructor() {\n    this.rRule = null;\n    this.rRuleSet = null;\n    this.validator = new RecurrenceValidator();\n  }\n  generateDates(options) {\n    var recurrenceRule = this.evalRecurrenceRule(options.rule);\n    var rule = recurrenceRule.rule;\n    if (!recurrenceRule.isValid || !rule.freq) {\n      return [];\n    }\n    var rruleIntervalParams = this._createRruleIntervalParams(options);\n    this._initializeRRule(options, rruleIntervalParams.startIntervalDate, rule.until);\n    return this.rRuleSet.between(rruleIntervalParams.minViewDate, rruleIntervalParams.maxViewDate, true).filter(date => date.getTime() + rruleIntervalParams.appointmentDuration >= rruleIntervalParams.minViewTime).map(date => this._convertRruleResult(rruleIntervalParams, options, date));\n  }\n  _createRruleIntervalParams(options) {\n    var {\n      start: start,\n      min: min,\n      max: max,\n      appointmentTimezoneOffset: appointmentTimezoneOffset\n    } = options;\n    var clientOffsets_startDate = timeZoneUtils.getClientTimezoneOffset(start),\n      clientOffsets_minViewDate = timeZoneUtils.getClientTimezoneOffset(min),\n      clientOffsets_maxViewDate = timeZoneUtils.getClientTimezoneOffset(max);\n    var duration = options.end ? options.end.getTime() - options.start.getTime() : 0;\n    var startIntervalDate = timeZoneUtils.setOffsetsToDate(options.start, [-clientOffsets_startDate, appointmentTimezoneOffset]);\n    var minViewTime = options.min.getTime() - clientOffsets_minViewDate + appointmentTimezoneOffset;\n    var minViewDate = new Date(minViewTime - duration);\n    var maxViewDate = timeZoneUtils.setOffsetsToDate(options.max, [-clientOffsets_maxViewDate, appointmentTimezoneOffset]);\n    var startDateDSTDifferenceMs = timeZoneUtils.getDiffBetweenClientTimezoneOffsets(options.start, startIntervalDate);\n    var switchToSummerTime = startDateDSTDifferenceMs < 0;\n    return {\n      startIntervalDate: startIntervalDate,\n      minViewTime: minViewTime,\n      minViewDate: minViewDate,\n      maxViewDate: maxViewDate,\n      startIntervalDateDSTShift: switchToSummerTime ? 0 : startDateDSTDifferenceMs,\n      appointmentDuration: duration\n    };\n  }\n  _convertRruleResult(rruleIntervalParams, options, rruleDate) {\n    var localTimezoneOffset = timeZoneUtils.getClientTimezoneOffset(rruleDate);\n    var additionalWorkaroundOffsetForRrule = localTimezoneOffset / MS_IN_HOUR <= -13 ? -MS_IN_DAY : 0;\n    var convertedBackDate = timeZoneUtils.setOffsetsToDate(rruleDate, [localTimezoneOffset, additionalWorkaroundOffsetForRrule, -options.appointmentTimezoneOffset, rruleIntervalParams.startIntervalDateDSTShift]);\n    var convertedDateDSTShift = timeZoneUtils.getDiffBetweenClientTimezoneOffsets(convertedBackDate, rruleDate);\n    var switchToSummerTime = convertedDateDSTShift < 0;\n    var resultDate = timeZoneUtils.setOffsetsToDate(convertedBackDate, [convertedDateDSTShift]);\n    var resultDateDSTShift = timeZoneUtils.getDiffBetweenClientTimezoneOffsets(resultDate, convertedBackDate);\n    if (resultDateDSTShift && switchToSummerTime) {\n      return new Date(resultDate.getTime() + resultDateDSTShift);\n    }\n    return resultDate;\n  }\n  hasRecurrence(options) {\n    return !!this.generateDates(options).length;\n  }\n  evalRecurrenceRule(rule) {\n    var result = {\n      rule: {},\n      isValid: false\n    };\n    if (rule) {\n      result.rule = this._parseRecurrenceRule(rule);\n      result.isValid = this.validator.validateRRule(result.rule, rule);\n    }\n    return result;\n  }\n  isValidRecurrenceRule(rule) {\n    return this.evalRecurrenceRule(rule).isValid;\n  }\n  daysFromByDayRule(rule) {\n    var result = [];\n    if (rule.byday) {\n      if (Array.isArray(rule.byday)) {\n        result = rule.byday;\n      } else {\n        result = rule.byday.split(\",\");\n      }\n    }\n    return result.map(item => {\n      var match = item.match(/[A-Za-z]+/);\n      return !!match && match[0];\n    }).filter(item => !!item);\n  }\n  getAsciiStringByDate(date) {\n    var currentOffset = date.getTimezoneOffset() * toMs(\"minute\");\n    var offsetDate = new Date(date.getTime() + currentOffset);\n    return offsetDate.getFullYear() + (\"0\" + (offsetDate.getMonth() + 1)).slice(-2) + (\"0\" + offsetDate.getDate()).slice(-2) + \"T\" + (\"0\" + offsetDate.getHours()).slice(-2) + (\"0\" + offsetDate.getMinutes()).slice(-2) + (\"0\" + offsetDate.getSeconds()).slice(-2) + \"Z\";\n  }\n  getRecurrenceString(object) {\n    if (!object || !object.freq) {\n      return;\n    }\n    var result = \"\";\n    for (var field in object) {\n      var value = object[field];\n      if (\"interval\" === field && value < 2) {\n        continue;\n      }\n      if (\"until\" === field) {\n        value = this.getAsciiStringByDate(value);\n      }\n      result += field + \"=\" + value + \";\";\n    }\n    result = result.substring(0, result.length - 1);\n    return result.toUpperCase();\n  }\n  _parseExceptionToRawArray(value) {\n    return value.match(/(\\d{4})(\\d{2})(\\d{2})(T(\\d{2})(\\d{2})(\\d{2}))?(Z)?/);\n  }\n  getDateByAsciiString(exceptionText) {\n    if (\"string\" !== typeof exceptionText) {\n      return exceptionText;\n    }\n    var result = this._parseExceptionToRawArray(exceptionText);\n    if (!result) {\n      return null;\n    }\n    var [year, month, date, hours, minutes, seconds, isUtc] = this._createDateTuple(result);\n    if (isUtc) {\n      return new Date(Date.UTC(year, month, date, hours, minutes, seconds));\n    }\n    return new Date(year, month, date, hours, minutes, seconds);\n  }\n  _dispose() {\n    if (this.rRuleSet) {\n      delete this.rRuleSet;\n      this.rRuleSet = null;\n    }\n    if (this.rRule) {\n      delete this.rRule;\n      this.rRule = null;\n    }\n  }\n  _getTimeZoneOffset() {\n    return new Date().getTimezoneOffset();\n  }\n  _initializeRRule(options, startDateUtc, until) {\n    var ruleOptions = RRule.parseString(options.rule);\n    var firstDayOfWeek = options.firstDayOfWeek;\n    ruleOptions.dtstart = startDateUtc;\n    if (!ruleOptions.wkst && firstDayOfWeek) {\n      ruleOptions.wkst = [6, 0, 1, 2, 3, 4, 5][firstDayOfWeek];\n    }\n    if (until) {\n      ruleOptions.until = timeZoneUtils.setOffsetsToDate(until, [-timeZoneUtils.getClientTimezoneOffset(until), options.appointmentTimezoneOffset]);\n    }\n    this._createRRule(ruleOptions);\n    if (options.exception) {\n      var exceptionStrings = options.exception;\n      var exceptionDates = exceptionStrings.split(\",\").map(rule => this.getDateByAsciiString(rule));\n      exceptionDates.forEach(date => {\n        if (options.getPostProcessedException) {\n          date = options.getPostProcessedException(date);\n        }\n        var utcDate = timeZoneUtils.setOffsetsToDate(date, [-timeZoneUtils.getClientTimezoneOffset(date), options.appointmentTimezoneOffset]);\n        this.rRuleSet.exdate(utcDate);\n      });\n    }\n  }\n  _createRRule(ruleOptions) {\n    this._dispose();\n    this.rRuleSet = new RRuleSet();\n    this.rRule = new RRule(ruleOptions);\n    this.rRuleSet.rrule(this.rRule);\n  }\n  _parseRecurrenceRule(recurrence) {\n    var ruleObject = {};\n    var ruleParts = recurrence.split(\";\");\n    for (var i = 0, len = ruleParts.length; i < len; i++) {\n      var rule = ruleParts[i].split(\"=\");\n      var ruleName = rule[0].toLowerCase();\n      var ruleValue = rule[1];\n      ruleObject[ruleName] = ruleValue;\n    }\n    var count = parseInt(ruleObject.count);\n    if (!isNaN(count)) {\n      ruleObject.count = count;\n    }\n    if (ruleObject.interval) {\n      var interval = parseInt(ruleObject.interval);\n      if (!isNaN(interval)) {\n        ruleObject.interval = interval;\n      }\n    } else {\n      ruleObject.interval = 1;\n    }\n    if (ruleObject.freq && ruleObject.until) {\n      ruleObject.until = this.getDateByAsciiString(ruleObject.until);\n    }\n    return ruleObject;\n  }\n  _createDateTuple(parseResult) {\n    var isUtc = void 0 !== parseResult[8];\n    parseResult.shift();\n    if (void 0 === parseResult[3]) {\n      parseResult.splice(3);\n    } else {\n      parseResult.splice(3, 1);\n      parseResult.splice(6);\n    }\n    parseResult[1]--;\n    parseResult.unshift(null);\n    return [parseInt(parseResult[1]), parseInt(parseResult[2]), parseInt(parseResult[3]), parseInt(parseResult[4]) || 0, parseInt(parseResult[5]) || 0, parseInt(parseResult[6]) || 0, isUtc];\n  }\n}\nclass RecurrenceValidator {\n  validateRRule(rule, recurrence) {\n    if (this._brokenRuleNameExists(rule) || !freqNames.includes(rule.freq) || this._wrongCountRule(rule) || this._wrongIntervalRule(rule) || this._wrongDayOfWeek(rule) || this._wrongByMonthDayRule(rule) || this._wrongByMonth(rule) || this._wrongUntilRule(rule)) {\n      this._logBrokenRule(recurrence);\n      return false;\n    }\n    return true;\n  }\n  _wrongUntilRule(rule) {\n    var wrongUntil = false;\n    var until = rule.until;\n    if (void 0 !== until && !(until instanceof Date)) {\n      wrongUntil = true;\n    }\n    return wrongUntil;\n  }\n  _wrongCountRule(rule) {\n    var wrongCount = false;\n    var count = rule.count;\n    if (count && \"string\" === typeof count) {\n      wrongCount = true;\n    }\n    return wrongCount;\n  }\n  _wrongByMonthDayRule(rule) {\n    var wrongByMonthDay = false;\n    var byMonthDay = rule.bymonthday;\n    if (byMonthDay && isNaN(parseInt(byMonthDay))) {\n      wrongByMonthDay = true;\n    }\n    return wrongByMonthDay;\n  }\n  _wrongByMonth(rule) {\n    var wrongByMonth = false;\n    var byMonth = rule.bymonth;\n    if (byMonth && isNaN(parseInt(byMonth))) {\n      wrongByMonth = true;\n    }\n    return wrongByMonth;\n  }\n  _wrongIntervalRule(rule) {\n    var wrongInterval = false;\n    var interval = rule.interval;\n    if (interval && \"string\" === typeof interval) {\n      wrongInterval = true;\n    }\n    return wrongInterval;\n  }\n  _wrongDayOfWeek(rule) {\n    var byDay = rule.byday;\n    var daysByRule = getRecurrenceProcessor().daysFromByDayRule(rule);\n    var brokenDaysExist = false;\n    if (\"\" === byDay) {\n      brokenDaysExist = true;\n    }\n    each(daysByRule, function (_, day) {\n      if (!Object.prototype.hasOwnProperty.call(days, day)) {\n        brokenDaysExist = true;\n        return false;\n      }\n    });\n    return brokenDaysExist;\n  }\n  _brokenRuleNameExists(rule) {\n    var brokenRuleExists = false;\n    each(rule, function (ruleName) {\n      if (!ruleNames.includes(ruleName)) {\n        brokenRuleExists = true;\n        return false;\n      }\n    });\n    return brokenRuleExists;\n  }\n  _logBrokenRule(recurrence) {\n    if (!loggedWarnings.includes(recurrence)) {\n      errors.log(\"W0006\", recurrence);\n      loggedWarnings.push(recurrence);\n    }\n  }\n}","map":{"version":3,"names":["errors","each","RRule","RRuleSet","dateUtils","timeZoneUtils","toMs","dateToMilliseconds","ruleNames","freqNames","days","SU","MO","TU","WE","TH","FR","SA","loggedWarnings","MS_IN_HOUR","MS_IN_DAY","recurrence","getRecurrenceProcessor","RecurrenceProcessor","constructor","rRule","rRuleSet","validator","RecurrenceValidator","generateDates","options","recurrenceRule","evalRecurrenceRule","rule","isValid","freq","rruleIntervalParams","_createRruleIntervalParams","_initializeRRule","startIntervalDate","until","between","minViewDate","maxViewDate","filter","date","getTime","appointmentDuration","minViewTime","map","_convertRruleResult","start","min","max","appointmentTimezoneOffset","clientOffsets_startDate","getClientTimezoneOffset","clientOffsets_minViewDate","clientOffsets_maxViewDate","duration","end","setOffsetsToDate","Date","startDateDSTDifferenceMs","getDiffBetweenClientTimezoneOffsets","switchToSummerTime","startIntervalDateDSTShift","rruleDate","localTimezoneOffset","additionalWorkaroundOffsetForRrule","convertedBackDate","convertedDateDSTShift","resultDate","resultDateDSTShift","hasRecurrence","length","result","_parseRecurrenceRule","validateRRule","isValidRecurrenceRule","daysFromByDayRule","byday","Array","isArray","split","item","match","getAsciiStringByDate","currentOffset","getTimezoneOffset","offsetDate","getFullYear","getMonth","slice","getDate","getHours","getMinutes","getSeconds","getRecurrenceString","object","field","value","substring","toUpperCase","_parseExceptionToRawArray","getDateByAsciiString","exceptionText","year","month","hours","minutes","seconds","isUtc","_createDateTuple","UTC","_dispose","_getTimeZoneOffset","startDateUtc","ruleOptions","parseString","firstDayOfWeek","dtstart","wkst","_createRRule","exception","exceptionStrings","exceptionDates","forEach","getPostProcessedException","utcDate","exdate","rrule","ruleObject","ruleParts","i","len","ruleName","toLowerCase","ruleValue","count","parseInt","isNaN","interval","parseResult","shift","splice","unshift","_brokenRuleNameExists","includes","_wrongCountRule","_wrongIntervalRule","_wrongDayOfWeek","_wrongByMonthDayRule","_wrongByMonth","_wrongUntilRule","_logBrokenRule","wrongUntil","wrongCount","wrongByMonthDay","byMonthDay","bymonthday","wrongByMonth","byMonth","bymonth","wrongInterval","byDay","daysByRule","brokenDaysExist","_","day","Object","prototype","hasOwnProperty","call","brokenRuleExists","log","push"],"sources":["C:/Users/Michal Abargel/Desktop/FULLSTACK_PROJECTS/Patient-Management/client/node_modules/devextreme/esm/ui/scheduler/recurrence.js"],"sourcesContent":["/**\r\n * DevExtreme (esm/ui/scheduler/recurrence.js)\r\n * Version: 23.1.5\r\n * Build date: Wed Aug 30 2023\r\n *\r\n * Copyright (c) 2012 - 2023 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\nimport errors from \"../../core/errors\";\r\nimport {\r\n    each\r\n} from \"../../core/utils/iterator\";\r\nimport {\r\n    RRule,\r\n    RRuleSet\r\n} from \"rrule\";\r\nimport dateUtils from \"../../core/utils/date\";\r\nimport timeZoneUtils from \"./utils.timeZone\";\r\nvar toMs = dateUtils.dateToMilliseconds;\r\nvar ruleNames = [\"freq\", \"interval\", \"byday\", \"byweekno\", \"byyearday\", \"bymonth\", \"bymonthday\", \"count\", \"until\", \"byhour\", \"byminute\", \"bysecond\", \"bysetpos\", \"wkst\"];\r\nvar freqNames = [\"DAILY\", \"WEEKLY\", \"MONTHLY\", \"YEARLY\", \"SECONDLY\", \"MINUTELY\", \"HOURLY\"];\r\nvar days = {\r\n    SU: 0,\r\n    MO: 1,\r\n    TU: 2,\r\n    WE: 3,\r\n    TH: 4,\r\n    FR: 5,\r\n    SA: 6\r\n};\r\nvar loggedWarnings = [];\r\nvar MS_IN_HOUR = 36e5;\r\nvar MS_IN_DAY = 24 * MS_IN_HOUR;\r\nvar recurrence = null;\r\nexport function getRecurrenceProcessor() {\r\n    if (!recurrence) {\r\n        recurrence = new RecurrenceProcessor\r\n    }\r\n    return recurrence\r\n}\r\nclass RecurrenceProcessor {\r\n    constructor() {\r\n        this.rRule = null;\r\n        this.rRuleSet = null;\r\n        this.validator = new RecurrenceValidator\r\n    }\r\n    generateDates(options) {\r\n        var recurrenceRule = this.evalRecurrenceRule(options.rule);\r\n        var rule = recurrenceRule.rule;\r\n        if (!recurrenceRule.isValid || !rule.freq) {\r\n            return []\r\n        }\r\n        var rruleIntervalParams = this._createRruleIntervalParams(options);\r\n        this._initializeRRule(options, rruleIntervalParams.startIntervalDate, rule.until);\r\n        return this.rRuleSet.between(rruleIntervalParams.minViewDate, rruleIntervalParams.maxViewDate, true).filter(date => date.getTime() + rruleIntervalParams.appointmentDuration >= rruleIntervalParams.minViewTime).map(date => this._convertRruleResult(rruleIntervalParams, options, date))\r\n    }\r\n    _createRruleIntervalParams(options) {\r\n        var {\r\n            start: start,\r\n            min: min,\r\n            max: max,\r\n            appointmentTimezoneOffset: appointmentTimezoneOffset\r\n        } = options;\r\n        var clientOffsets_startDate = timeZoneUtils.getClientTimezoneOffset(start),\r\n            clientOffsets_minViewDate = timeZoneUtils.getClientTimezoneOffset(min),\r\n            clientOffsets_maxViewDate = timeZoneUtils.getClientTimezoneOffset(max);\r\n        var duration = options.end ? options.end.getTime() - options.start.getTime() : 0;\r\n        var startIntervalDate = timeZoneUtils.setOffsetsToDate(options.start, [-clientOffsets_startDate, appointmentTimezoneOffset]);\r\n        var minViewTime = options.min.getTime() - clientOffsets_minViewDate + appointmentTimezoneOffset;\r\n        var minViewDate = new Date(minViewTime - duration);\r\n        var maxViewDate = timeZoneUtils.setOffsetsToDate(options.max, [-clientOffsets_maxViewDate, appointmentTimezoneOffset]);\r\n        var startDateDSTDifferenceMs = timeZoneUtils.getDiffBetweenClientTimezoneOffsets(options.start, startIntervalDate);\r\n        var switchToSummerTime = startDateDSTDifferenceMs < 0;\r\n        return {\r\n            startIntervalDate: startIntervalDate,\r\n            minViewTime: minViewTime,\r\n            minViewDate: minViewDate,\r\n            maxViewDate: maxViewDate,\r\n            startIntervalDateDSTShift: switchToSummerTime ? 0 : startDateDSTDifferenceMs,\r\n            appointmentDuration: duration\r\n        }\r\n    }\r\n    _convertRruleResult(rruleIntervalParams, options, rruleDate) {\r\n        var localTimezoneOffset = timeZoneUtils.getClientTimezoneOffset(rruleDate);\r\n        var additionalWorkaroundOffsetForRrule = localTimezoneOffset / MS_IN_HOUR <= -13 ? -MS_IN_DAY : 0;\r\n        var convertedBackDate = timeZoneUtils.setOffsetsToDate(rruleDate, [localTimezoneOffset, additionalWorkaroundOffsetForRrule, -options.appointmentTimezoneOffset, rruleIntervalParams.startIntervalDateDSTShift]);\r\n        var convertedDateDSTShift = timeZoneUtils.getDiffBetweenClientTimezoneOffsets(convertedBackDate, rruleDate);\r\n        var switchToSummerTime = convertedDateDSTShift < 0;\r\n        var resultDate = timeZoneUtils.setOffsetsToDate(convertedBackDate, [convertedDateDSTShift]);\r\n        var resultDateDSTShift = timeZoneUtils.getDiffBetweenClientTimezoneOffsets(resultDate, convertedBackDate);\r\n        if (resultDateDSTShift && switchToSummerTime) {\r\n            return new Date(resultDate.getTime() + resultDateDSTShift)\r\n        }\r\n        return resultDate\r\n    }\r\n    hasRecurrence(options) {\r\n        return !!this.generateDates(options).length\r\n    }\r\n    evalRecurrenceRule(rule) {\r\n        var result = {\r\n            rule: {},\r\n            isValid: false\r\n        };\r\n        if (rule) {\r\n            result.rule = this._parseRecurrenceRule(rule);\r\n            result.isValid = this.validator.validateRRule(result.rule, rule)\r\n        }\r\n        return result\r\n    }\r\n    isValidRecurrenceRule(rule) {\r\n        return this.evalRecurrenceRule(rule).isValid\r\n    }\r\n    daysFromByDayRule(rule) {\r\n        var result = [];\r\n        if (rule.byday) {\r\n            if (Array.isArray(rule.byday)) {\r\n                result = rule.byday\r\n            } else {\r\n                result = rule.byday.split(\",\")\r\n            }\r\n        }\r\n        return result.map(item => {\r\n            var match = item.match(/[A-Za-z]+/);\r\n            return !!match && match[0]\r\n        }).filter(item => !!item)\r\n    }\r\n    getAsciiStringByDate(date) {\r\n        var currentOffset = date.getTimezoneOffset() * toMs(\"minute\");\r\n        var offsetDate = new Date(date.getTime() + currentOffset);\r\n        return offsetDate.getFullYear() + (\"0\" + (offsetDate.getMonth() + 1)).slice(-2) + (\"0\" + offsetDate.getDate()).slice(-2) + \"T\" + (\"0\" + offsetDate.getHours()).slice(-2) + (\"0\" + offsetDate.getMinutes()).slice(-2) + (\"0\" + offsetDate.getSeconds()).slice(-2) + \"Z\"\r\n    }\r\n    getRecurrenceString(object) {\r\n        if (!object || !object.freq) {\r\n            return\r\n        }\r\n        var result = \"\";\r\n        for (var field in object) {\r\n            var value = object[field];\r\n            if (\"interval\" === field && value < 2) {\r\n                continue\r\n            }\r\n            if (\"until\" === field) {\r\n                value = this.getAsciiStringByDate(value)\r\n            }\r\n            result += field + \"=\" + value + \";\"\r\n        }\r\n        result = result.substring(0, result.length - 1);\r\n        return result.toUpperCase()\r\n    }\r\n    _parseExceptionToRawArray(value) {\r\n        return value.match(/(\\d{4})(\\d{2})(\\d{2})(T(\\d{2})(\\d{2})(\\d{2}))?(Z)?/)\r\n    }\r\n    getDateByAsciiString(exceptionText) {\r\n        if (\"string\" !== typeof exceptionText) {\r\n            return exceptionText\r\n        }\r\n        var result = this._parseExceptionToRawArray(exceptionText);\r\n        if (!result) {\r\n            return null\r\n        }\r\n        var [year, month, date, hours, minutes, seconds, isUtc] = this._createDateTuple(result);\r\n        if (isUtc) {\r\n            return new Date(Date.UTC(year, month, date, hours, minutes, seconds))\r\n        }\r\n        return new Date(year, month, date, hours, minutes, seconds)\r\n    }\r\n    _dispose() {\r\n        if (this.rRuleSet) {\r\n            delete this.rRuleSet;\r\n            this.rRuleSet = null\r\n        }\r\n        if (this.rRule) {\r\n            delete this.rRule;\r\n            this.rRule = null\r\n        }\r\n    }\r\n    _getTimeZoneOffset() {\r\n        return (new Date).getTimezoneOffset()\r\n    }\r\n    _initializeRRule(options, startDateUtc, until) {\r\n        var ruleOptions = RRule.parseString(options.rule);\r\n        var firstDayOfWeek = options.firstDayOfWeek;\r\n        ruleOptions.dtstart = startDateUtc;\r\n        if (!ruleOptions.wkst && firstDayOfWeek) {\r\n            ruleOptions.wkst = [6, 0, 1, 2, 3, 4, 5][firstDayOfWeek]\r\n        }\r\n        if (until) {\r\n            ruleOptions.until = timeZoneUtils.setOffsetsToDate(until, [-timeZoneUtils.getClientTimezoneOffset(until), options.appointmentTimezoneOffset])\r\n        }\r\n        this._createRRule(ruleOptions);\r\n        if (options.exception) {\r\n            var exceptionStrings = options.exception;\r\n            var exceptionDates = exceptionStrings.split(\",\").map(rule => this.getDateByAsciiString(rule));\r\n            exceptionDates.forEach(date => {\r\n                if (options.getPostProcessedException) {\r\n                    date = options.getPostProcessedException(date)\r\n                }\r\n                var utcDate = timeZoneUtils.setOffsetsToDate(date, [-timeZoneUtils.getClientTimezoneOffset(date), options.appointmentTimezoneOffset]);\r\n                this.rRuleSet.exdate(utcDate)\r\n            })\r\n        }\r\n    }\r\n    _createRRule(ruleOptions) {\r\n        this._dispose();\r\n        this.rRuleSet = new RRuleSet;\r\n        this.rRule = new RRule(ruleOptions);\r\n        this.rRuleSet.rrule(this.rRule)\r\n    }\r\n    _parseRecurrenceRule(recurrence) {\r\n        var ruleObject = {};\r\n        var ruleParts = recurrence.split(\";\");\r\n        for (var i = 0, len = ruleParts.length; i < len; i++) {\r\n            var rule = ruleParts[i].split(\"=\");\r\n            var ruleName = rule[0].toLowerCase();\r\n            var ruleValue = rule[1];\r\n            ruleObject[ruleName] = ruleValue\r\n        }\r\n        var count = parseInt(ruleObject.count);\r\n        if (!isNaN(count)) {\r\n            ruleObject.count = count\r\n        }\r\n        if (ruleObject.interval) {\r\n            var interval = parseInt(ruleObject.interval);\r\n            if (!isNaN(interval)) {\r\n                ruleObject.interval = interval\r\n            }\r\n        } else {\r\n            ruleObject.interval = 1\r\n        }\r\n        if (ruleObject.freq && ruleObject.until) {\r\n            ruleObject.until = this.getDateByAsciiString(ruleObject.until)\r\n        }\r\n        return ruleObject\r\n    }\r\n    _createDateTuple(parseResult) {\r\n        var isUtc = void 0 !== parseResult[8];\r\n        parseResult.shift();\r\n        if (void 0 === parseResult[3]) {\r\n            parseResult.splice(3)\r\n        } else {\r\n            parseResult.splice(3, 1);\r\n            parseResult.splice(6)\r\n        }\r\n        parseResult[1]--;\r\n        parseResult.unshift(null);\r\n        return [parseInt(parseResult[1]), parseInt(parseResult[2]), parseInt(parseResult[3]), parseInt(parseResult[4]) || 0, parseInt(parseResult[5]) || 0, parseInt(parseResult[6]) || 0, isUtc]\r\n    }\r\n}\r\nclass RecurrenceValidator {\r\n    validateRRule(rule, recurrence) {\r\n        if (this._brokenRuleNameExists(rule) || !freqNames.includes(rule.freq) || this._wrongCountRule(rule) || this._wrongIntervalRule(rule) || this._wrongDayOfWeek(rule) || this._wrongByMonthDayRule(rule) || this._wrongByMonth(rule) || this._wrongUntilRule(rule)) {\r\n            this._logBrokenRule(recurrence);\r\n            return false\r\n        }\r\n        return true\r\n    }\r\n    _wrongUntilRule(rule) {\r\n        var wrongUntil = false;\r\n        var until = rule.until;\r\n        if (void 0 !== until && !(until instanceof Date)) {\r\n            wrongUntil = true\r\n        }\r\n        return wrongUntil\r\n    }\r\n    _wrongCountRule(rule) {\r\n        var wrongCount = false;\r\n        var count = rule.count;\r\n        if (count && \"string\" === typeof count) {\r\n            wrongCount = true\r\n        }\r\n        return wrongCount\r\n    }\r\n    _wrongByMonthDayRule(rule) {\r\n        var wrongByMonthDay = false;\r\n        var byMonthDay = rule.bymonthday;\r\n        if (byMonthDay && isNaN(parseInt(byMonthDay))) {\r\n            wrongByMonthDay = true\r\n        }\r\n        return wrongByMonthDay\r\n    }\r\n    _wrongByMonth(rule) {\r\n        var wrongByMonth = false;\r\n        var byMonth = rule.bymonth;\r\n        if (byMonth && isNaN(parseInt(byMonth))) {\r\n            wrongByMonth = true\r\n        }\r\n        return wrongByMonth\r\n    }\r\n    _wrongIntervalRule(rule) {\r\n        var wrongInterval = false;\r\n        var interval = rule.interval;\r\n        if (interval && \"string\" === typeof interval) {\r\n            wrongInterval = true\r\n        }\r\n        return wrongInterval\r\n    }\r\n    _wrongDayOfWeek(rule) {\r\n        var byDay = rule.byday;\r\n        var daysByRule = getRecurrenceProcessor().daysFromByDayRule(rule);\r\n        var brokenDaysExist = false;\r\n        if (\"\" === byDay) {\r\n            brokenDaysExist = true\r\n        }\r\n        each(daysByRule, (function(_, day) {\r\n            if (!Object.prototype.hasOwnProperty.call(days, day)) {\r\n                brokenDaysExist = true;\r\n                return false\r\n            }\r\n        }));\r\n        return brokenDaysExist\r\n    }\r\n    _brokenRuleNameExists(rule) {\r\n        var brokenRuleExists = false;\r\n        each(rule, (function(ruleName) {\r\n            if (!ruleNames.includes(ruleName)) {\r\n                brokenRuleExists = true;\r\n                return false\r\n            }\r\n        }));\r\n        return brokenRuleExists\r\n    }\r\n    _logBrokenRule(recurrence) {\r\n        if (!loggedWarnings.includes(recurrence)) {\r\n            errors.log(\"W0006\", recurrence);\r\n            loggedWarnings.push(recurrence)\r\n        }\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}