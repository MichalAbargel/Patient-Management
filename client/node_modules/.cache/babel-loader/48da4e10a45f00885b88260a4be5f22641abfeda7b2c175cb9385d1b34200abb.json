{"ast":null,"code":"/**\r\n * DevExtreme (esm/ui/scheduler/workspaces/view_model/grouped_data_map_provider.js)\r\n * Version: 23.1.5\r\n * Build date: Wed Aug 30 2023\r\n *\r\n * Copyright (c) 2012 - 2023 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport dateUtils from \"../../../../core/utils/date\";\nimport { isDateAndTimeView } from \"../../../../renovation/ui/scheduler/view_model/to_test/views/utils/base\";\nexport class GroupedDataMapProvider {\n  constructor(viewDataGenerator, viewDataMap, completeViewDataMap, viewOptions) {\n    this.groupedDataMap = viewDataGenerator.generateGroupedDataMap(viewDataMap);\n    this.completeViewDataMap = completeViewDataMap;\n    this._viewOptions = viewOptions;\n  }\n  getGroupStartDate(groupIndex) {\n    var firstRow = this.getFirstGroupRow(groupIndex);\n    if (firstRow) {\n      var {\n        startDate: startDate\n      } = firstRow[0].cellData;\n      return startDate;\n    }\n  }\n  getGroupEndDate(groupIndex) {\n    var lastRow = this.getLastGroupRow(groupIndex);\n    if (lastRow) {\n      var lastColumnIndex = lastRow.length - 1;\n      var {\n        cellData: cellData\n      } = lastRow[lastColumnIndex];\n      var {\n        endDate: endDate\n      } = cellData;\n      return endDate;\n    }\n  }\n  findGroupCellStartDate(groupIndex, startDate, endDate, isFindByDate) {\n    var groupData = this.getGroupFromDateTableGroupMap(groupIndex);\n    var checkCellStartDate = (rowIndex, columnIndex) => {\n      var {\n        cellData: cellData\n      } = groupData[rowIndex][columnIndex];\n      var {\n        startDate: secondMin,\n        endDate: secondMax\n      } = cellData;\n      if (isFindByDate) {\n        secondMin = dateUtils.trimTime(secondMin);\n        secondMax = dateUtils.setToDayEnd(secondMin);\n      }\n      if (dateUtils.intervalsOverlap({\n        firstMin: startDate,\n        firstMax: endDate,\n        secondMin: secondMin,\n        secondMax: secondMax\n      })) {\n        return secondMin;\n      }\n    };\n    var startDateVerticalSearch = (() => {\n      var cellCount = groupData[0].length;\n      for (var columnIndex = 0; columnIndex < cellCount; ++columnIndex) {\n        for (var rowIndex = 0; rowIndex < groupData.length; ++rowIndex) {\n          var result = checkCellStartDate(rowIndex, columnIndex);\n          if (result) {\n            return result;\n          }\n        }\n      }\n    })();\n    var startDateHorizontalSearch = (() => {\n      for (var rowIndex = 0; rowIndex < groupData.length; ++rowIndex) {\n        var row = groupData[rowIndex];\n        for (var columnIndex = 0; columnIndex < row.length; ++columnIndex) {\n          var result = checkCellStartDate(rowIndex, columnIndex);\n          if (result) {\n            return result;\n          }\n        }\n      }\n    })();\n    return startDateVerticalSearch > startDateHorizontalSearch ? startDateHorizontalSearch : startDateVerticalSearch;\n  }\n  findAllDayGroupCellStartDate(groupIndex, startDate) {\n    var groupStartDate = this.getGroupStartDate(groupIndex);\n    return groupStartDate > startDate ? groupStartDate : startDate;\n  }\n  findCellPositionInMap(cellInfo) {\n    var {\n      groupIndex: groupIndex,\n      startDate: startDate,\n      isAllDay: isAllDay,\n      index: index\n    } = cellInfo;\n    var startTime = isAllDay ? dateUtils.trimTime(startDate).getTime() : startDate.getTime();\n    var isStartDateInCell = cellData => {\n      if (!isDateAndTimeView(this._viewOptions.viewType)) {\n        return dateUtils.sameDate(startDate, cellData.startDate);\n      }\n      var cellStartTime = cellData.startDate.getTime();\n      var cellEndTime = cellData.endDate.getTime();\n      return isAllDay ? cellData.allDay && startTime >= cellStartTime && startTime <= cellEndTime : startTime >= cellStartTime && startTime < cellEndTime;\n    };\n    var {\n      allDayPanelGroupedMap: allDayPanelGroupedMap,\n      dateTableGroupedMap: dateTableGroupedMap\n    } = this.groupedDataMap;\n    var rows = isAllDay && !this._viewOptions.isVerticalGrouping ? allDayPanelGroupedMap[groupIndex] ? [allDayPanelGroupedMap[groupIndex]] : [] : dateTableGroupedMap[groupIndex] || [];\n    for (var rowIndex = 0; rowIndex < rows.length; ++rowIndex) {\n      var row = rows[rowIndex];\n      for (var columnIndex = 0; columnIndex < row.length; ++columnIndex) {\n        var cell = row[columnIndex];\n        var {\n          cellData: cellData\n        } = cell;\n        if (this._isSameGroupIndexAndIndex(cellData, groupIndex, index)) {\n          if (isStartDateInCell(cellData)) {\n            return cell.position;\n          }\n        }\n      }\n    }\n    return;\n  }\n  _isSameGroupIndexAndIndex(cellData, groupIndex, index) {\n    return cellData.groupIndex === groupIndex && (void 0 === index || cellData.index === index);\n  }\n  getCellsGroup(groupIndex) {\n    var {\n      dateTableGroupedMap: dateTableGroupedMap\n    } = this.groupedDataMap;\n    var groupData = dateTableGroupedMap[groupIndex];\n    if (groupData) {\n      var {\n        cellData: cellData\n      } = groupData[0][0];\n      return cellData.groups;\n    }\n  }\n  getCompletedGroupsInfo() {\n    var {\n      dateTableGroupedMap: dateTableGroupedMap\n    } = this.groupedDataMap;\n    return dateTableGroupedMap.map(groupData => {\n      var firstCell = groupData[0][0];\n      var {\n        allDay: allDay,\n        groupIndex: groupIndex\n      } = firstCell.cellData;\n      return {\n        allDay: allDay,\n        groupIndex: groupIndex,\n        startDate: this.getGroupStartDate(groupIndex),\n        endDate: this.getGroupEndDate(groupIndex)\n      };\n    }).filter(_ref => {\n      var {\n        startDate: startDate\n      } = _ref;\n      return !!startDate;\n    });\n  }\n  getGroupIndices() {\n    return this.getCompletedGroupsInfo().map(_ref2 => {\n      var {\n        groupIndex: groupIndex\n      } = _ref2;\n      return groupIndex;\n    });\n  }\n  getGroupFromDateTableGroupMap(groupIndex) {\n    var {\n      dateTableGroupedMap: dateTableGroupedMap\n    } = this.groupedDataMap;\n    return dateTableGroupedMap[groupIndex];\n  }\n  getFirstGroupRow(groupIndex) {\n    var groupedData = this.getGroupFromDateTableGroupMap(groupIndex);\n    if (groupedData) {\n      var {\n        cellData: cellData\n      } = groupedData[0][0];\n      return !cellData.allDay ? groupedData[0] : groupedData[1];\n    }\n  }\n  getLastGroupRow(groupIndex) {\n    var {\n      dateTableGroupedMap: dateTableGroupedMap\n    } = this.groupedDataMap;\n    var groupedData = dateTableGroupedMap[groupIndex];\n    if (groupedData) {\n      var lastRowIndex = groupedData.length - 1;\n      return groupedData[lastRowIndex];\n    }\n  }\n  getLastGroupCellPosition(groupIndex) {\n    var groupRow = this.getLastGroupRow(groupIndex);\n    return null === groupRow || void 0 === groupRow ? void 0 : groupRow[(null === groupRow || void 0 === groupRow ? void 0 : groupRow.length) - 1].position;\n  }\n  getRowCountInGroup(groupIndex) {\n    var groupRow = this.getLastGroupRow(groupIndex);\n    var cellAmount = groupRow.length;\n    var lastCellData = groupRow[cellAmount - 1].cellData;\n    var lastCellIndex = lastCellData.index;\n    return (lastCellIndex + 1) / groupRow.length;\n  }\n}","map":{"version":3,"names":["dateUtils","isDateAndTimeView","GroupedDataMapProvider","constructor","viewDataGenerator","viewDataMap","completeViewDataMap","viewOptions","groupedDataMap","generateGroupedDataMap","_viewOptions","getGroupStartDate","groupIndex","firstRow","getFirstGroupRow","startDate","cellData","getGroupEndDate","lastRow","getLastGroupRow","lastColumnIndex","length","endDate","findGroupCellStartDate","isFindByDate","groupData","getGroupFromDateTableGroupMap","checkCellStartDate","rowIndex","columnIndex","secondMin","secondMax","trimTime","setToDayEnd","intervalsOverlap","firstMin","firstMax","startDateVerticalSearch","cellCount","result","startDateHorizontalSearch","row","findAllDayGroupCellStartDate","groupStartDate","findCellPositionInMap","cellInfo","isAllDay","index","startTime","getTime","isStartDateInCell","viewType","sameDate","cellStartTime","cellEndTime","allDay","allDayPanelGroupedMap","dateTableGroupedMap","rows","isVerticalGrouping","cell","_isSameGroupIndexAndIndex","position","getCellsGroup","groups","getCompletedGroupsInfo","map","firstCell","filter","_ref","getGroupIndices","_ref2","groupedData","lastRowIndex","getLastGroupCellPosition","groupRow","getRowCountInGroup","cellAmount","lastCellData","lastCellIndex"],"sources":["C:/Users/Michal Abargel/Desktop/FULLSTACK_PROJECTS/PrivateLessones/PL/client/gui/node_modules/devextreme/esm/ui/scheduler/workspaces/view_model/grouped_data_map_provider.js"],"sourcesContent":["/**\r\n * DevExtreme (esm/ui/scheduler/workspaces/view_model/grouped_data_map_provider.js)\r\n * Version: 23.1.5\r\n * Build date: Wed Aug 30 2023\r\n *\r\n * Copyright (c) 2012 - 2023 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\nimport dateUtils from \"../../../../core/utils/date\";\r\nimport {\r\n    isDateAndTimeView\r\n} from \"../../../../renovation/ui/scheduler/view_model/to_test/views/utils/base\";\r\nexport class GroupedDataMapProvider {\r\n    constructor(viewDataGenerator, viewDataMap, completeViewDataMap, viewOptions) {\r\n        this.groupedDataMap = viewDataGenerator.generateGroupedDataMap(viewDataMap);\r\n        this.completeViewDataMap = completeViewDataMap;\r\n        this._viewOptions = viewOptions\r\n    }\r\n    getGroupStartDate(groupIndex) {\r\n        var firstRow = this.getFirstGroupRow(groupIndex);\r\n        if (firstRow) {\r\n            var {\r\n                startDate: startDate\r\n            } = firstRow[0].cellData;\r\n            return startDate\r\n        }\r\n    }\r\n    getGroupEndDate(groupIndex) {\r\n        var lastRow = this.getLastGroupRow(groupIndex);\r\n        if (lastRow) {\r\n            var lastColumnIndex = lastRow.length - 1;\r\n            var {\r\n                cellData: cellData\r\n            } = lastRow[lastColumnIndex];\r\n            var {\r\n                endDate: endDate\r\n            } = cellData;\r\n            return endDate\r\n        }\r\n    }\r\n    findGroupCellStartDate(groupIndex, startDate, endDate, isFindByDate) {\r\n        var groupData = this.getGroupFromDateTableGroupMap(groupIndex);\r\n        var checkCellStartDate = (rowIndex, columnIndex) => {\r\n            var {\r\n                cellData: cellData\r\n            } = groupData[rowIndex][columnIndex];\r\n            var {\r\n                startDate: secondMin,\r\n                endDate: secondMax\r\n            } = cellData;\r\n            if (isFindByDate) {\r\n                secondMin = dateUtils.trimTime(secondMin);\r\n                secondMax = dateUtils.setToDayEnd(secondMin)\r\n            }\r\n            if (dateUtils.intervalsOverlap({\r\n                    firstMin: startDate,\r\n                    firstMax: endDate,\r\n                    secondMin: secondMin,\r\n                    secondMax: secondMax\r\n                })) {\r\n                return secondMin\r\n            }\r\n        };\r\n        var startDateVerticalSearch = (() => {\r\n            var cellCount = groupData[0].length;\r\n            for (var columnIndex = 0; columnIndex < cellCount; ++columnIndex) {\r\n                for (var rowIndex = 0; rowIndex < groupData.length; ++rowIndex) {\r\n                    var result = checkCellStartDate(rowIndex, columnIndex);\r\n                    if (result) {\r\n                        return result\r\n                    }\r\n                }\r\n            }\r\n        })();\r\n        var startDateHorizontalSearch = (() => {\r\n            for (var rowIndex = 0; rowIndex < groupData.length; ++rowIndex) {\r\n                var row = groupData[rowIndex];\r\n                for (var columnIndex = 0; columnIndex < row.length; ++columnIndex) {\r\n                    var result = checkCellStartDate(rowIndex, columnIndex);\r\n                    if (result) {\r\n                        return result\r\n                    }\r\n                }\r\n            }\r\n        })();\r\n        return startDateVerticalSearch > startDateHorizontalSearch ? startDateHorizontalSearch : startDateVerticalSearch\r\n    }\r\n    findAllDayGroupCellStartDate(groupIndex, startDate) {\r\n        var groupStartDate = this.getGroupStartDate(groupIndex);\r\n        return groupStartDate > startDate ? groupStartDate : startDate\r\n    }\r\n    findCellPositionInMap(cellInfo) {\r\n        var {\r\n            groupIndex: groupIndex,\r\n            startDate: startDate,\r\n            isAllDay: isAllDay,\r\n            index: index\r\n        } = cellInfo;\r\n        var startTime = isAllDay ? dateUtils.trimTime(startDate).getTime() : startDate.getTime();\r\n        var isStartDateInCell = cellData => {\r\n            if (!isDateAndTimeView(this._viewOptions.viewType)) {\r\n                return dateUtils.sameDate(startDate, cellData.startDate)\r\n            }\r\n            var cellStartTime = cellData.startDate.getTime();\r\n            var cellEndTime = cellData.endDate.getTime();\r\n            return isAllDay ? cellData.allDay && startTime >= cellStartTime && startTime <= cellEndTime : startTime >= cellStartTime && startTime < cellEndTime\r\n        };\r\n        var {\r\n            allDayPanelGroupedMap: allDayPanelGroupedMap,\r\n            dateTableGroupedMap: dateTableGroupedMap\r\n        } = this.groupedDataMap;\r\n        var rows = isAllDay && !this._viewOptions.isVerticalGrouping ? allDayPanelGroupedMap[groupIndex] ? [allDayPanelGroupedMap[groupIndex]] : [] : dateTableGroupedMap[groupIndex] || [];\r\n        for (var rowIndex = 0; rowIndex < rows.length; ++rowIndex) {\r\n            var row = rows[rowIndex];\r\n            for (var columnIndex = 0; columnIndex < row.length; ++columnIndex) {\r\n                var cell = row[columnIndex];\r\n                var {\r\n                    cellData: cellData\r\n                } = cell;\r\n                if (this._isSameGroupIndexAndIndex(cellData, groupIndex, index)) {\r\n                    if (isStartDateInCell(cellData)) {\r\n                        return cell.position\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return\r\n    }\r\n    _isSameGroupIndexAndIndex(cellData, groupIndex, index) {\r\n        return cellData.groupIndex === groupIndex && (void 0 === index || cellData.index === index)\r\n    }\r\n    getCellsGroup(groupIndex) {\r\n        var {\r\n            dateTableGroupedMap: dateTableGroupedMap\r\n        } = this.groupedDataMap;\r\n        var groupData = dateTableGroupedMap[groupIndex];\r\n        if (groupData) {\r\n            var {\r\n                cellData: cellData\r\n            } = groupData[0][0];\r\n            return cellData.groups\r\n        }\r\n    }\r\n    getCompletedGroupsInfo() {\r\n        var {\r\n            dateTableGroupedMap: dateTableGroupedMap\r\n        } = this.groupedDataMap;\r\n        return dateTableGroupedMap.map(groupData => {\r\n            var firstCell = groupData[0][0];\r\n            var {\r\n                allDay: allDay,\r\n                groupIndex: groupIndex\r\n            } = firstCell.cellData;\r\n            return {\r\n                allDay: allDay,\r\n                groupIndex: groupIndex,\r\n                startDate: this.getGroupStartDate(groupIndex),\r\n                endDate: this.getGroupEndDate(groupIndex)\r\n            }\r\n        }).filter(_ref => {\r\n            var {\r\n                startDate: startDate\r\n            } = _ref;\r\n            return !!startDate\r\n        })\r\n    }\r\n    getGroupIndices() {\r\n        return this.getCompletedGroupsInfo().map(_ref2 => {\r\n            var {\r\n                groupIndex: groupIndex\r\n            } = _ref2;\r\n            return groupIndex\r\n        })\r\n    }\r\n    getGroupFromDateTableGroupMap(groupIndex) {\r\n        var {\r\n            dateTableGroupedMap: dateTableGroupedMap\r\n        } = this.groupedDataMap;\r\n        return dateTableGroupedMap[groupIndex]\r\n    }\r\n    getFirstGroupRow(groupIndex) {\r\n        var groupedData = this.getGroupFromDateTableGroupMap(groupIndex);\r\n        if (groupedData) {\r\n            var {\r\n                cellData: cellData\r\n            } = groupedData[0][0];\r\n            return !cellData.allDay ? groupedData[0] : groupedData[1]\r\n        }\r\n    }\r\n    getLastGroupRow(groupIndex) {\r\n        var {\r\n            dateTableGroupedMap: dateTableGroupedMap\r\n        } = this.groupedDataMap;\r\n        var groupedData = dateTableGroupedMap[groupIndex];\r\n        if (groupedData) {\r\n            var lastRowIndex = groupedData.length - 1;\r\n            return groupedData[lastRowIndex]\r\n        }\r\n    }\r\n    getLastGroupCellPosition(groupIndex) {\r\n        var groupRow = this.getLastGroupRow(groupIndex);\r\n        return null === groupRow || void 0 === groupRow ? void 0 : groupRow[(null === groupRow || void 0 === groupRow ? void 0 : groupRow.length) - 1].position\r\n    }\r\n    getRowCountInGroup(groupIndex) {\r\n        var groupRow = this.getLastGroupRow(groupIndex);\r\n        var cellAmount = groupRow.length;\r\n        var lastCellData = groupRow[cellAmount - 1].cellData;\r\n        var lastCellIndex = lastCellData.index;\r\n        return (lastCellIndex + 1) / groupRow.length\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}