{"ast":null,"code":"/**\r\n * DevExtreme (esm/__internal/scheduler/appointments/m_settings_generator.js)\r\n * Version: 23.1.5\r\n * Build date: Wed Aug 30 2023\r\n *\r\n * Copyright (c) 2012 - 2023 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport dateUtils from \"../../../core/utils/date\";\nimport { extend } from \"../../../core/utils/extend\";\nimport { isEmptyObject } from \"../../../core/utils/type\";\nimport { isDateAndTimeView } from \"../../../renovation/ui/scheduler/view_model/to_test/views/utils/base\";\nimport { createAppointmentAdapter } from \"../../../ui/scheduler/appointmentAdapter\";\nimport { ExpressionUtils } from \"../../../ui/scheduler/expressionUtils\";\nimport { getRecurrenceProcessor } from \"../../../ui/scheduler/recurrence\";\nimport timeZoneUtils from \"../../../ui/scheduler/utils.timeZone\";\nimport { createResourcesTree, getDataAccessors, getGroupCount, getResourceTreeLeaves } from \"../resources/m_utils\";\nimport { CellPositionCalculator } from \"./m_cell_position_calculator\";\nimport { createFormattedDateText } from \"./m_text_utils\";\nvar toMs = dateUtils.dateToMilliseconds;\nvar APPOINTMENT_DATE_TEXT_FORMAT = \"TIME\";\nexport class DateGeneratorBaseStrategy {\n  constructor(options) {\n    this.options = options;\n  }\n  get rawAppointment() {\n    return this.options.rawAppointment;\n  }\n  get timeZoneCalculator() {\n    return this.options.timeZoneCalculator;\n  }\n  get viewDataProvider() {\n    return this.options.viewDataProvider;\n  }\n  get appointmentTakesAllDay() {\n    return this.options.appointmentTakesAllDay;\n  }\n  get supportAllDayRow() {\n    return this.options.supportAllDayRow;\n  }\n  get isAllDayRowAppointment() {\n    return this.options.isAllDayRowAppointment;\n  }\n  get timeZone() {\n    return this.options.timeZone;\n  }\n  get dateRange() {\n    return this.options.dateRange;\n  }\n  get firstDayOfWeek() {\n    return this.options.firstDayOfWeek;\n  }\n  get viewStartDayHour() {\n    return this.options.viewStartDayHour;\n  }\n  get viewEndDayHour() {\n    return this.options.viewEndDayHour;\n  }\n  get endViewDate() {\n    return this.options.endViewDate;\n  }\n  get viewType() {\n    return this.options.viewType;\n  }\n  get isGroupedByDate() {\n    return this.options.isGroupedByDate;\n  }\n  get isVerticalOrientation() {\n    return this.options.isVerticalGroupOrientation;\n  }\n  get dataAccessors() {\n    return this.options.dataAccessors;\n  }\n  get loadedResources() {\n    return this.options.loadedResources;\n  }\n  get isDateAppointment() {\n    return !isDateAndTimeView(this.viewType) && this.appointmentTakesAllDay;\n  }\n  getIntervalDuration() {\n    return this.appointmentTakesAllDay ? this.options.allDayIntervalDuration : this.options.intervalDuration;\n  }\n  generate(appointmentAdapter) {\n    var itemGroupIndices = this._getGroupIndices(this.rawAppointment);\n    var appointmentList = this._createAppointments(appointmentAdapter, itemGroupIndices);\n    appointmentList = this._getProcessedByAppointmentTimeZone(appointmentList, appointmentAdapter);\n    if (this._canProcessNotNativeTimezoneDates(appointmentAdapter)) {\n      appointmentList = this._getProcessedNotNativeTimezoneDates(appointmentList, appointmentAdapter);\n    }\n    var dateSettings = this._createGridAppointmentList(appointmentList, appointmentAdapter);\n    var firstViewDates = this._getAppointmentsFirstViewDate(dateSettings);\n    this._fillNormalizedStartDate(dateSettings, firstViewDates);\n    dateSettings = this._cropAppointmentsByStartDayHour(dateSettings, firstViewDates);\n    dateSettings = this._fillNormalizedEndDate(dateSettings, this.rawAppointment);\n    if (this._needSeparateLongParts()) {\n      dateSettings = this._separateLongParts(dateSettings, appointmentAdapter);\n    }\n    var {\n      isRecurrent: isRecurrent\n    } = appointmentAdapter;\n    return {\n      dateSettings: dateSettings,\n      itemGroupIndices: itemGroupIndices,\n      isRecurrent: isRecurrent\n    };\n  }\n  _getProcessedByAppointmentTimeZone(appointmentList, appointment) {\n    var hasAppointmentTimeZone = !isEmptyObject(appointment.startDateTimeZone) || !isEmptyObject(appointment.endDateTimeZone);\n    if (hasAppointmentTimeZone) {\n      var appointmentOffsets = {\n        startDate: this.timeZoneCalculator.getOffsets(appointment.startDate, appointment.startDateTimeZone),\n        endDate: this.timeZoneCalculator.getOffsets(appointment.endDate, appointment.endDateTimeZone)\n      };\n      appointmentList.forEach(a => {\n        var sourceOffsets_startDate = this.timeZoneCalculator.getOffsets(a.startDate, appointment.startDateTimeZone),\n          sourceOffsets_endDate = this.timeZoneCalculator.getOffsets(a.endDate, appointment.endDateTimeZone);\n        var startDateOffsetDiff = appointmentOffsets.startDate.appointment - sourceOffsets_startDate.appointment;\n        var endDateOffsetDiff = appointmentOffsets.endDate.appointment - sourceOffsets_endDate.appointment;\n        if (sourceOffsets_startDate.appointment !== sourceOffsets_startDate.common) {\n          a.startDate = new Date(a.startDate.getTime() + startDateOffsetDiff * toMs(\"hour\"));\n        }\n        if (sourceOffsets_endDate.appointment !== sourceOffsets_endDate.common) {\n          a.endDate = new Date(a.endDate.getTime() + endDateOffsetDiff * toMs(\"hour\"));\n        }\n      });\n    }\n    return appointmentList;\n  }\n  _createAppointments(appointment, groupIndices) {\n    var appointments = this._createRecurrenceAppointments(appointment, groupIndices);\n    if (!appointment.isRecurrent && 0 === appointments.length) {\n      appointments.push({\n        startDate: appointment.startDate,\n        endDate: appointment.endDate\n      });\n    }\n    appointments = appointments.map(item => {\n      var _a;\n      var resultEndTime = null === (_a = item.endDate) || void 0 === _a ? void 0 : _a.getTime();\n      if (item.startDate.getTime() === resultEndTime) {\n        item.endDate.setTime(resultEndTime + toMs(\"minute\"));\n      }\n      return _extends(_extends({}, item), {\n        exceptionDate: new Date(item.startDate)\n      });\n    });\n    return appointments;\n  }\n  _canProcessNotNativeTimezoneDates(appointment) {\n    var isTimeZoneSet = !isEmptyObject(this.timeZone);\n    if (!isTimeZoneSet) {\n      return false;\n    }\n    if (!appointment.isRecurrent) {\n      return false;\n    }\n    return !timeZoneUtils.isEqualLocalTimeZone(this.timeZone, appointment.startDate);\n  }\n  _getProcessedNotNativeDateIfCrossDST(date, offset) {\n    if (offset < 0) {\n      var newDate = new Date(date);\n      var newDateMinusOneHour = new Date(newDate);\n      newDateMinusOneHour.setHours(newDateMinusOneHour.getHours() - 1);\n      var newDateOffset = this.timeZoneCalculator.getOffsets(newDate).common;\n      var newDateMinusOneHourOffset = this.timeZoneCalculator.getOffsets(newDateMinusOneHour).common;\n      if (newDateOffset !== newDateMinusOneHourOffset) {\n        return 0;\n      }\n    }\n    return offset;\n  }\n  _getCommonOffset(date) {\n    return this.timeZoneCalculator.getOffsets(date).common;\n  }\n  _getProcessedNotNativeTimezoneDates(appointmentList, appointment) {\n    return appointmentList.map(item => {\n      var diffStartDateOffset = this._getCommonOffset(appointment.startDate) - this._getCommonOffset(item.startDate);\n      var diffEndDateOffset = this._getCommonOffset(appointment.endDate) - this._getCommonOffset(item.endDate);\n      if (0 === diffStartDateOffset && 0 === diffEndDateOffset) {\n        return item;\n      }\n      diffStartDateOffset = this._getProcessedNotNativeDateIfCrossDST(item.startDate, diffStartDateOffset);\n      diffEndDateOffset = this._getProcessedNotNativeDateIfCrossDST(item.endDate, diffEndDateOffset);\n      var newStartDate = new Date(item.startDate.getTime() + diffStartDateOffset * toMs(\"hour\"));\n      var newEndDate = new Date(item.endDate.getTime() + diffEndDateOffset * toMs(\"hour\"));\n      var testNewStartDate = this.timeZoneCalculator.createDate(newStartDate, {\n        path: \"toGrid\"\n      });\n      var testNewEndDate = this.timeZoneCalculator.createDate(newEndDate, {\n        path: \"toGrid\"\n      });\n      if (appointment.duration > testNewEndDate.getTime() - testNewStartDate.getTime()) {\n        newEndDate = new Date(newStartDate.getTime() + appointment.duration);\n      }\n      return _extends(_extends({}, item), {\n        startDate: newStartDate,\n        endDate: newEndDate,\n        exceptionDate: new Date(newStartDate)\n      });\n    });\n  }\n  _needSeparateLongParts() {\n    return this.isVerticalOrientation ? this.isGroupedByDate : this.isGroupedByDate && this.appointmentTakesAllDay;\n  }\n  normalizeEndDateByViewEnd(rawAppointment, endDate) {\n    var result = new Date(endDate.getTime());\n    var isAllDay = isDateAndTimeView(this.viewType) && this.appointmentTakesAllDay;\n    if (!isAllDay) {\n      var roundedEndViewDate = dateUtils.roundToHour(this.endViewDate);\n      if (result > roundedEndViewDate) {\n        result = roundedEndViewDate;\n      }\n    }\n    var endDayHour = this.viewEndDayHour;\n    var allDay = ExpressionUtils.getField(this.dataAccessors, \"allDay\", rawAppointment);\n    var currentViewEndTime = new Date(new Date(endDate.getTime()).setHours(endDayHour, 0, 0, 0));\n    if (result.getTime() > currentViewEndTime.getTime() || allDay && result.getHours() < endDayHour) {\n      result = currentViewEndTime;\n    }\n    return result;\n  }\n  _fillNormalizedEndDate(dateSettings, rawAppointment) {\n    return dateSettings.map(item => {\n      var {\n        endDate: endDate\n      } = item;\n      var normalizedEndDate = this.normalizeEndDateByViewEnd(rawAppointment, endDate);\n      return _extends(_extends({}, item), {\n        normalizedEndDate: normalizedEndDate\n      });\n    });\n  }\n  _separateLongParts(gridAppointmentList, appointmentAdapter) {\n    var result = [];\n    gridAppointmentList.forEach(gridAppointment => {\n      var maxDate = new Date(this.dateRange[1]);\n      var {\n        normalizedEndDate: endDateOfPart\n      } = gridAppointment;\n      var longStartDateParts = dateUtils.getDatesOfInterval(gridAppointment.startDate, endDateOfPart, {\n        milliseconds: this.getIntervalDuration()\n      });\n      var list = longStartDateParts.filter(startDatePart => new Date(startDatePart) < maxDate).map(date => {\n        var endDate = new Date(new Date(date).setMilliseconds(appointmentAdapter.duration));\n        var normalizedEndDate = this.normalizeEndDateByViewEnd(this.rawAppointment, endDate);\n        return {\n          startDate: date,\n          endDate: endDate,\n          normalizedEndDate: normalizedEndDate,\n          source: gridAppointment.source\n        };\n      });\n      result = result.concat(list);\n    });\n    return result;\n  }\n  _createGridAppointmentList(appointmentList, appointmentAdapter) {\n    return appointmentList.map(source => {\n      var offsetDifference = appointmentAdapter.startDate.getTimezoneOffset() - source.startDate.getTimezoneOffset();\n      if (0 !== offsetDifference && this._canProcessNotNativeTimezoneDates(appointmentAdapter)) {\n        source.startDate = new Date(source.startDate.getTime() + offsetDifference * toMs(\"minute\"));\n        source.endDate = new Date(source.endDate.getTime() + offsetDifference * toMs(\"minute\"));\n        source.exceptionDate = new Date(source.startDate);\n      }\n      var startDate = this.timeZoneCalculator.createDate(source.startDate, {\n        path: \"toGrid\"\n      });\n      var endDate = this.timeZoneCalculator.createDate(source.endDate, {\n        path: \"toGrid\"\n      });\n      return {\n        startDate: startDate,\n        endDate: endDate,\n        allDay: appointmentAdapter.allDay || false,\n        source: source\n      };\n    });\n  }\n  _createExtremeRecurrenceDates(groupIndex) {\n    var startViewDate = this.appointmentTakesAllDay ? dateUtils.trimTime(this.dateRange[0]) : this.dateRange[0];\n    var endViewDateByEndDayHour = this.dateRange[1];\n    if (this.timeZone) {\n      startViewDate = this.timeZoneCalculator.createDate(startViewDate, {\n        path: \"fromGrid\"\n      });\n      endViewDateByEndDayHour = this.timeZoneCalculator.createDate(endViewDateByEndDayHour, {\n        path: \"fromGrid\"\n      });\n      var daylightOffset = timeZoneUtils.getDaylightOffsetInMs(startViewDate, endViewDateByEndDayHour);\n      if (daylightOffset) {\n        endViewDateByEndDayHour = new Date(endViewDateByEndDayHour.getTime() + daylightOffset);\n      }\n    }\n    return [startViewDate, endViewDateByEndDayHour];\n  }\n  _createRecurrenceOptions(appointment, groupIndex) {\n    var [minRecurrenceDate, maxRecurrenceDate] = this._createExtremeRecurrenceDates(groupIndex);\n    return {\n      rule: appointment.recurrenceRule,\n      exception: appointment.recurrenceException,\n      min: minRecurrenceDate,\n      max: maxRecurrenceDate,\n      firstDayOfWeek: this.firstDayOfWeek,\n      start: appointment.startDate,\n      end: appointment.endDate,\n      appointmentTimezoneOffset: this.timeZoneCalculator.getOriginStartDateOffsetInMs(appointment.startDate, appointment.rawAppointment.startDateTimeZone, true),\n      getPostProcessedException: date => {\n        if (isEmptyObject(this.timeZone) || timeZoneUtils.isEqualLocalTimeZone(this.timeZone, date)) {\n          return date;\n        }\n        var appointmentOffset = this.timeZoneCalculator.getOffsets(appointment.startDate).common;\n        var exceptionAppointmentOffset = this.timeZoneCalculator.getOffsets(date).common;\n        var diff = appointmentOffset - exceptionAppointmentOffset;\n        diff = this._getProcessedNotNativeDateIfCrossDST(date, diff);\n        return new Date(date.getTime() - diff * dateUtils.dateToMilliseconds(\"hour\"));\n      }\n    };\n  }\n  _createRecurrenceAppointments(appointment, groupIndices) {\n    var {\n      duration: duration\n    } = appointment;\n    var option = this._createRecurrenceOptions(appointment);\n    var generatedStartDates = getRecurrenceProcessor().generateDates(option);\n    return generatedStartDates.map(date => {\n      var utcDate = timeZoneUtils.createUTCDateWithLocalOffset(date);\n      utcDate.setTime(utcDate.getTime() + duration);\n      var endDate = timeZoneUtils.createDateFromUTCWithLocalOffset(utcDate);\n      return {\n        startDate: new Date(date),\n        endDate: endDate\n      };\n    });\n  }\n  _getAppointmentsFirstViewDate(appointments) {\n    return appointments.map(appointment => this._getAppointmentFirstViewDate(appointment));\n  }\n  _fillNormalizedStartDate(appointments, firstViewDates, rawAppointment) {\n    appointments.forEach((appointment, idx) => {\n      appointment.startDate = this._getAppointmentResultDate({\n        appointment: appointment,\n        rawAppointment: rawAppointment,\n        startDate: new Date(appointment.startDate),\n        startDayHour: this.viewStartDayHour,\n        firstViewDate: firstViewDates[idx]\n      });\n    });\n  }\n  _cropAppointmentsByStartDayHour(appointments, firstViewDates) {\n    return appointments.filter((appointment, idx) => {\n      if (!firstViewDates[idx]) {\n        return false;\n      }\n      if (this.appointmentTakesAllDay) {\n        return true;\n      }\n      return appointment.endDate > appointment.startDate;\n    });\n  }\n  _getAppointmentResultDate(options) {\n    var {\n      appointment: appointment,\n      startDayHour: startDayHour,\n      firstViewDate: firstViewDate\n    } = options;\n    var {\n      startDate: startDate\n    } = options;\n    var resultDate;\n    if (this.appointmentTakesAllDay) {\n      resultDate = dateUtils.normalizeDate(startDate, firstViewDate);\n    } else {\n      if (startDate < firstViewDate) {\n        startDate = firstViewDate;\n      }\n      resultDate = dateUtils.normalizeDate(appointment.startDate, startDate);\n    }\n    return !this.isDateAppointment ? dateUtils.roundDateByStartDayHour(resultDate, startDayHour) : resultDate;\n  }\n  _getAppointmentFirstViewDate(appointment) {\n    var groupIndex = appointment.source.groupIndex || 0;\n    var {\n      startDate: startDate,\n      endDate: endDate\n    } = appointment;\n    if (this.isAllDayRowAppointment || appointment.allDay) {\n      return this.viewDataProvider.findAllDayGroupCellStartDate(groupIndex, startDate);\n    }\n    return this.viewDataProvider.findGroupCellStartDate(groupIndex, startDate, endDate, this.isDateAppointment);\n  }\n  _getGroupIndices(rawAppointment) {\n    var result = [];\n    if (rawAppointment && this.loadedResources.length) {\n      var tree = createResourcesTree(this.loadedResources);\n      result = getResourceTreeLeaves((field, action) => getDataAccessors(this.options.dataAccessors.resources, field, action), tree, rawAppointment);\n    }\n    return result;\n  }\n}\nexport class DateGeneratorVirtualStrategy extends DateGeneratorBaseStrategy {\n  get groupCount() {\n    return getGroupCount(this.loadedResources);\n  }\n  _createRecurrenceAppointments(appointment, groupIndices) {\n    var {\n      duration: duration\n    } = appointment;\n    var result = [];\n    var validGroupIndices = this.groupCount ? groupIndices : [0];\n    validGroupIndices.forEach(groupIndex => {\n      var option = this._createRecurrenceOptions(appointment, groupIndex);\n      var generatedStartDates = getRecurrenceProcessor().generateDates(option);\n      var recurrentInfo = generatedStartDates.map(date => {\n        var startDate = new Date(date);\n        var utcDate = timeZoneUtils.createUTCDateWithLocalOffset(date);\n        utcDate.setTime(utcDate.getTime() + duration);\n        var endDate = timeZoneUtils.createDateFromUTCWithLocalOffset(utcDate);\n        return {\n          startDate: startDate,\n          endDate: endDate,\n          groupIndex: groupIndex\n        };\n      });\n      result.push(...recurrentInfo);\n    });\n    return result;\n  }\n  _updateGroupIndices(appointments, groupIndices) {\n    var result = [];\n    groupIndices.forEach(groupIndex => {\n      var groupStartDate = this.viewDataProvider.getGroupStartDate(groupIndex);\n      if (groupStartDate) {\n        appointments.forEach(appointment => {\n          var appointmentCopy = extend({}, appointment);\n          appointmentCopy.groupIndex = groupIndex;\n          result.push(appointmentCopy);\n        });\n      }\n    });\n    return result;\n  }\n  _getGroupIndices(resources) {\n    var groupIndices = super._getGroupIndices(resources);\n    var viewDataGroupIndices = this.viewDataProvider.getGroupIndices();\n    if (!(null === groupIndices || void 0 === groupIndices ? void 0 : groupIndices.length)) {\n      groupIndices = [0];\n    }\n    return groupIndices.filter(groupIndex => -1 !== viewDataGroupIndices.indexOf(groupIndex));\n  }\n  _createAppointments(appointment, groupIndices) {\n    var appointments = super._createAppointments(appointment, groupIndices);\n    return !appointment.isRecurrent ? this._updateGroupIndices(appointments, groupIndices) : appointments;\n  }\n}\nexport class AppointmentSettingsGenerator {\n  constructor(options) {\n    this.options = options;\n    this.appointmentAdapter = createAppointmentAdapter(this.rawAppointment, this.dataAccessors, this.timeZoneCalculator);\n  }\n  get rawAppointment() {\n    return this.options.rawAppointment;\n  }\n  get dataAccessors() {\n    return this.options.dataAccessors;\n  }\n  get timeZoneCalculator() {\n    return this.options.timeZoneCalculator;\n  }\n  get isAllDayRowAppointment() {\n    return this.options.appointmentTakesAllDay && this.options.supportAllDayRow;\n  }\n  get groups() {\n    return this.options.groups;\n  }\n  get dateSettingsStrategy() {\n    var options = _extends(_extends({}, this.options), {\n      isAllDayRowAppointment: this.isAllDayRowAppointment\n    });\n    return this.options.isVirtualScrolling ? new DateGeneratorVirtualStrategy(options) : new DateGeneratorBaseStrategy(options);\n  }\n  create() {\n    var {\n      dateSettings: dateSettings,\n      itemGroupIndices: itemGroupIndices,\n      isRecurrent: isRecurrent\n    } = this._generateDateSettings();\n    var cellPositions = this._calculateCellPositions(dateSettings, itemGroupIndices);\n    var result = this._prepareAppointmentInfos(dateSettings, cellPositions, isRecurrent);\n    return result;\n  }\n  _generateDateSettings() {\n    return this.dateSettingsStrategy.generate(this.appointmentAdapter);\n  }\n  _calculateCellPositions(dateSettings, itemGroupIndices) {\n    var cellPositionCalculator = new CellPositionCalculator(_extends(_extends({}, this.options), {\n      dateSettings: dateSettings\n    }));\n    return cellPositionCalculator.calculateCellPositions(itemGroupIndices, this.isAllDayRowAppointment, this.appointmentAdapter.isRecurrent);\n  }\n  _prepareAppointmentInfos(dateSettings, cellPositions, isRecurrent) {\n    var infos = [];\n    cellPositions.forEach(_ref => {\n      var {\n        coordinates: coordinates,\n        dateSettingIndex: dateSettingIndex\n      } = _ref;\n      var dateSetting = dateSettings[dateSettingIndex];\n      var dateText = this._getAppointmentDateText(dateSetting);\n      var info = {\n        appointment: dateSetting,\n        sourceAppointment: dateSetting.source,\n        dateText: dateText,\n        isRecurrent: isRecurrent\n      };\n      infos.push(_extends(_extends({}, coordinates), {\n        info: info\n      }));\n    });\n    return infos;\n  }\n  _getAppointmentDateText(sourceAppointment) {\n    var {\n      startDate: startDate,\n      endDate: endDate,\n      allDay: allDay\n    } = sourceAppointment;\n    return createFormattedDateText({\n      startDate: startDate,\n      endDate: endDate,\n      allDay: allDay,\n      format: APPOINTMENT_DATE_TEXT_FORMAT\n    });\n  }\n}","map":{"version":3,"names":["_extends","dateUtils","extend","isEmptyObject","isDateAndTimeView","createAppointmentAdapter","ExpressionUtils","getRecurrenceProcessor","timeZoneUtils","createResourcesTree","getDataAccessors","getGroupCount","getResourceTreeLeaves","CellPositionCalculator","createFormattedDateText","toMs","dateToMilliseconds","APPOINTMENT_DATE_TEXT_FORMAT","DateGeneratorBaseStrategy","constructor","options","rawAppointment","timeZoneCalculator","viewDataProvider","appointmentTakesAllDay","supportAllDayRow","isAllDayRowAppointment","timeZone","dateRange","firstDayOfWeek","viewStartDayHour","viewEndDayHour","endViewDate","viewType","isGroupedByDate","isVerticalOrientation","isVerticalGroupOrientation","dataAccessors","loadedResources","isDateAppointment","getIntervalDuration","allDayIntervalDuration","intervalDuration","generate","appointmentAdapter","itemGroupIndices","_getGroupIndices","appointmentList","_createAppointments","_getProcessedByAppointmentTimeZone","_canProcessNotNativeTimezoneDates","_getProcessedNotNativeTimezoneDates","dateSettings","_createGridAppointmentList","firstViewDates","_getAppointmentsFirstViewDate","_fillNormalizedStartDate","_cropAppointmentsByStartDayHour","_fillNormalizedEndDate","_needSeparateLongParts","_separateLongParts","isRecurrent","appointment","hasAppointmentTimeZone","startDateTimeZone","endDateTimeZone","appointmentOffsets","startDate","getOffsets","endDate","forEach","a","sourceOffsets_startDate","sourceOffsets_endDate","startDateOffsetDiff","endDateOffsetDiff","common","Date","getTime","groupIndices","appointments","_createRecurrenceAppointments","length","push","map","item","_a","resultEndTime","setTime","exceptionDate","isTimeZoneSet","isEqualLocalTimeZone","_getProcessedNotNativeDateIfCrossDST","date","offset","newDate","newDateMinusOneHour","setHours","getHours","newDateOffset","newDateMinusOneHourOffset","_getCommonOffset","diffStartDateOffset","diffEndDateOffset","newStartDate","newEndDate","testNewStartDate","createDate","path","testNewEndDate","duration","normalizeEndDateByViewEnd","result","isAllDay","roundedEndViewDate","roundToHour","endDayHour","allDay","getField","currentViewEndTime","normalizedEndDate","gridAppointmentList","gridAppointment","maxDate","endDateOfPart","longStartDateParts","getDatesOfInterval","milliseconds","list","filter","startDatePart","setMilliseconds","source","concat","offsetDifference","getTimezoneOffset","_createExtremeRecurrenceDates","groupIndex","startViewDate","trimTime","endViewDateByEndDayHour","daylightOffset","getDaylightOffsetInMs","_createRecurrenceOptions","minRecurrenceDate","maxRecurrenceDate","rule","recurrenceRule","exception","recurrenceException","min","max","start","end","appointmentTimezoneOffset","getOriginStartDateOffsetInMs","getPostProcessedException","appointmentOffset","exceptionAppointmentOffset","diff","option","generatedStartDates","generateDates","utcDate","createUTCDateWithLocalOffset","createDateFromUTCWithLocalOffset","_getAppointmentFirstViewDate","idx","_getAppointmentResultDate","startDayHour","firstViewDate","resultDate","normalizeDate","roundDateByStartDayHour","findAllDayGroupCellStartDate","findGroupCellStartDate","tree","field","action","resources","DateGeneratorVirtualStrategy","groupCount","validGroupIndices","recurrentInfo","_updateGroupIndices","groupStartDate","getGroupStartDate","appointmentCopy","viewDataGroupIndices","getGroupIndices","indexOf","AppointmentSettingsGenerator","groups","dateSettingsStrategy","isVirtualScrolling","create","_generateDateSettings","cellPositions","_calculateCellPositions","_prepareAppointmentInfos","cellPositionCalculator","calculateCellPositions","infos","_ref","coordinates","dateSettingIndex","dateSetting","dateText","_getAppointmentDateText","info","sourceAppointment","format"],"sources":["C:/Users/Michal Abargel/Desktop/FULLSTACK_PROJECTS/PrivateLessones/PL/client/gui/node_modules/devextreme/esm/__internal/scheduler/appointments/m_settings_generator.js"],"sourcesContent":["/**\r\n * DevExtreme (esm/__internal/scheduler/appointments/m_settings_generator.js)\r\n * Version: 23.1.5\r\n * Build date: Wed Aug 30 2023\r\n *\r\n * Copyright (c) 2012 - 2023 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\r\nimport dateUtils from \"../../../core/utils/date\";\r\nimport {\r\n    extend\r\n} from \"../../../core/utils/extend\";\r\nimport {\r\n    isEmptyObject\r\n} from \"../../../core/utils/type\";\r\nimport {\r\n    isDateAndTimeView\r\n} from \"../../../renovation/ui/scheduler/view_model/to_test/views/utils/base\";\r\nimport {\r\n    createAppointmentAdapter\r\n} from \"../../../ui/scheduler/appointmentAdapter\";\r\nimport {\r\n    ExpressionUtils\r\n} from \"../../../ui/scheduler/expressionUtils\";\r\nimport {\r\n    getRecurrenceProcessor\r\n} from \"../../../ui/scheduler/recurrence\";\r\nimport timeZoneUtils from \"../../../ui/scheduler/utils.timeZone\";\r\nimport {\r\n    createResourcesTree,\r\n    getDataAccessors,\r\n    getGroupCount,\r\n    getResourceTreeLeaves\r\n} from \"../resources/m_utils\";\r\nimport {\r\n    CellPositionCalculator\r\n} from \"./m_cell_position_calculator\";\r\nimport {\r\n    createFormattedDateText\r\n} from \"./m_text_utils\";\r\nvar toMs = dateUtils.dateToMilliseconds;\r\nvar APPOINTMENT_DATE_TEXT_FORMAT = \"TIME\";\r\nexport class DateGeneratorBaseStrategy {\r\n    constructor(options) {\r\n        this.options = options\r\n    }\r\n    get rawAppointment() {\r\n        return this.options.rawAppointment\r\n    }\r\n    get timeZoneCalculator() {\r\n        return this.options.timeZoneCalculator\r\n    }\r\n    get viewDataProvider() {\r\n        return this.options.viewDataProvider\r\n    }\r\n    get appointmentTakesAllDay() {\r\n        return this.options.appointmentTakesAllDay\r\n    }\r\n    get supportAllDayRow() {\r\n        return this.options.supportAllDayRow\r\n    }\r\n    get isAllDayRowAppointment() {\r\n        return this.options.isAllDayRowAppointment\r\n    }\r\n    get timeZone() {\r\n        return this.options.timeZone\r\n    }\r\n    get dateRange() {\r\n        return this.options.dateRange\r\n    }\r\n    get firstDayOfWeek() {\r\n        return this.options.firstDayOfWeek\r\n    }\r\n    get viewStartDayHour() {\r\n        return this.options.viewStartDayHour\r\n    }\r\n    get viewEndDayHour() {\r\n        return this.options.viewEndDayHour\r\n    }\r\n    get endViewDate() {\r\n        return this.options.endViewDate\r\n    }\r\n    get viewType() {\r\n        return this.options.viewType\r\n    }\r\n    get isGroupedByDate() {\r\n        return this.options.isGroupedByDate\r\n    }\r\n    get isVerticalOrientation() {\r\n        return this.options.isVerticalGroupOrientation\r\n    }\r\n    get dataAccessors() {\r\n        return this.options.dataAccessors\r\n    }\r\n    get loadedResources() {\r\n        return this.options.loadedResources\r\n    }\r\n    get isDateAppointment() {\r\n        return !isDateAndTimeView(this.viewType) && this.appointmentTakesAllDay\r\n    }\r\n    getIntervalDuration() {\r\n        return this.appointmentTakesAllDay ? this.options.allDayIntervalDuration : this.options.intervalDuration\r\n    }\r\n    generate(appointmentAdapter) {\r\n        var itemGroupIndices = this._getGroupIndices(this.rawAppointment);\r\n        var appointmentList = this._createAppointments(appointmentAdapter, itemGroupIndices);\r\n        appointmentList = this._getProcessedByAppointmentTimeZone(appointmentList, appointmentAdapter);\r\n        if (this._canProcessNotNativeTimezoneDates(appointmentAdapter)) {\r\n            appointmentList = this._getProcessedNotNativeTimezoneDates(appointmentList, appointmentAdapter)\r\n        }\r\n        var dateSettings = this._createGridAppointmentList(appointmentList, appointmentAdapter);\r\n        var firstViewDates = this._getAppointmentsFirstViewDate(dateSettings);\r\n        this._fillNormalizedStartDate(dateSettings, firstViewDates);\r\n        dateSettings = this._cropAppointmentsByStartDayHour(dateSettings, firstViewDates);\r\n        dateSettings = this._fillNormalizedEndDate(dateSettings, this.rawAppointment);\r\n        if (this._needSeparateLongParts()) {\r\n            dateSettings = this._separateLongParts(dateSettings, appointmentAdapter)\r\n        }\r\n        var {\r\n            isRecurrent: isRecurrent\r\n        } = appointmentAdapter;\r\n        return {\r\n            dateSettings: dateSettings,\r\n            itemGroupIndices: itemGroupIndices,\r\n            isRecurrent: isRecurrent\r\n        }\r\n    }\r\n    _getProcessedByAppointmentTimeZone(appointmentList, appointment) {\r\n        var hasAppointmentTimeZone = !isEmptyObject(appointment.startDateTimeZone) || !isEmptyObject(appointment.endDateTimeZone);\r\n        if (hasAppointmentTimeZone) {\r\n            var appointmentOffsets = {\r\n                startDate: this.timeZoneCalculator.getOffsets(appointment.startDate, appointment.startDateTimeZone),\r\n                endDate: this.timeZoneCalculator.getOffsets(appointment.endDate, appointment.endDateTimeZone)\r\n            };\r\n            appointmentList.forEach(a => {\r\n                var sourceOffsets_startDate = this.timeZoneCalculator.getOffsets(a.startDate, appointment.startDateTimeZone),\r\n                    sourceOffsets_endDate = this.timeZoneCalculator.getOffsets(a.endDate, appointment.endDateTimeZone);\r\n                var startDateOffsetDiff = appointmentOffsets.startDate.appointment - sourceOffsets_startDate.appointment;\r\n                var endDateOffsetDiff = appointmentOffsets.endDate.appointment - sourceOffsets_endDate.appointment;\r\n                if (sourceOffsets_startDate.appointment !== sourceOffsets_startDate.common) {\r\n                    a.startDate = new Date(a.startDate.getTime() + startDateOffsetDiff * toMs(\"hour\"))\r\n                }\r\n                if (sourceOffsets_endDate.appointment !== sourceOffsets_endDate.common) {\r\n                    a.endDate = new Date(a.endDate.getTime() + endDateOffsetDiff * toMs(\"hour\"))\r\n                }\r\n            })\r\n        }\r\n        return appointmentList\r\n    }\r\n    _createAppointments(appointment, groupIndices) {\r\n        var appointments = this._createRecurrenceAppointments(appointment, groupIndices);\r\n        if (!appointment.isRecurrent && 0 === appointments.length) {\r\n            appointments.push({\r\n                startDate: appointment.startDate,\r\n                endDate: appointment.endDate\r\n            })\r\n        }\r\n        appointments = appointments.map(item => {\r\n            var _a;\r\n            var resultEndTime = null === (_a = item.endDate) || void 0 === _a ? void 0 : _a.getTime();\r\n            if (item.startDate.getTime() === resultEndTime) {\r\n                item.endDate.setTime(resultEndTime + toMs(\"minute\"))\r\n            }\r\n            return _extends(_extends({}, item), {\r\n                exceptionDate: new Date(item.startDate)\r\n            })\r\n        });\r\n        return appointments\r\n    }\r\n    _canProcessNotNativeTimezoneDates(appointment) {\r\n        var isTimeZoneSet = !isEmptyObject(this.timeZone);\r\n        if (!isTimeZoneSet) {\r\n            return false\r\n        }\r\n        if (!appointment.isRecurrent) {\r\n            return false\r\n        }\r\n        return !timeZoneUtils.isEqualLocalTimeZone(this.timeZone, appointment.startDate)\r\n    }\r\n    _getProcessedNotNativeDateIfCrossDST(date, offset) {\r\n        if (offset < 0) {\r\n            var newDate = new Date(date);\r\n            var newDateMinusOneHour = new Date(newDate);\r\n            newDateMinusOneHour.setHours(newDateMinusOneHour.getHours() - 1);\r\n            var newDateOffset = this.timeZoneCalculator.getOffsets(newDate).common;\r\n            var newDateMinusOneHourOffset = this.timeZoneCalculator.getOffsets(newDateMinusOneHour).common;\r\n            if (newDateOffset !== newDateMinusOneHourOffset) {\r\n                return 0\r\n            }\r\n        }\r\n        return offset\r\n    }\r\n    _getCommonOffset(date) {\r\n        return this.timeZoneCalculator.getOffsets(date).common\r\n    }\r\n    _getProcessedNotNativeTimezoneDates(appointmentList, appointment) {\r\n        return appointmentList.map(item => {\r\n            var diffStartDateOffset = this._getCommonOffset(appointment.startDate) - this._getCommonOffset(item.startDate);\r\n            var diffEndDateOffset = this._getCommonOffset(appointment.endDate) - this._getCommonOffset(item.endDate);\r\n            if (0 === diffStartDateOffset && 0 === diffEndDateOffset) {\r\n                return item\r\n            }\r\n            diffStartDateOffset = this._getProcessedNotNativeDateIfCrossDST(item.startDate, diffStartDateOffset);\r\n            diffEndDateOffset = this._getProcessedNotNativeDateIfCrossDST(item.endDate, diffEndDateOffset);\r\n            var newStartDate = new Date(item.startDate.getTime() + diffStartDateOffset * toMs(\"hour\"));\r\n            var newEndDate = new Date(item.endDate.getTime() + diffEndDateOffset * toMs(\"hour\"));\r\n            var testNewStartDate = this.timeZoneCalculator.createDate(newStartDate, {\r\n                path: \"toGrid\"\r\n            });\r\n            var testNewEndDate = this.timeZoneCalculator.createDate(newEndDate, {\r\n                path: \"toGrid\"\r\n            });\r\n            if (appointment.duration > testNewEndDate.getTime() - testNewStartDate.getTime()) {\r\n                newEndDate = new Date(newStartDate.getTime() + appointment.duration)\r\n            }\r\n            return _extends(_extends({}, item), {\r\n                startDate: newStartDate,\r\n                endDate: newEndDate,\r\n                exceptionDate: new Date(newStartDate)\r\n            })\r\n        })\r\n    }\r\n    _needSeparateLongParts() {\r\n        return this.isVerticalOrientation ? this.isGroupedByDate : this.isGroupedByDate && this.appointmentTakesAllDay\r\n    }\r\n    normalizeEndDateByViewEnd(rawAppointment, endDate) {\r\n        var result = new Date(endDate.getTime());\r\n        var isAllDay = isDateAndTimeView(this.viewType) && this.appointmentTakesAllDay;\r\n        if (!isAllDay) {\r\n            var roundedEndViewDate = dateUtils.roundToHour(this.endViewDate);\r\n            if (result > roundedEndViewDate) {\r\n                result = roundedEndViewDate\r\n            }\r\n        }\r\n        var endDayHour = this.viewEndDayHour;\r\n        var allDay = ExpressionUtils.getField(this.dataAccessors, \"allDay\", rawAppointment);\r\n        var currentViewEndTime = new Date(new Date(endDate.getTime()).setHours(endDayHour, 0, 0, 0));\r\n        if (result.getTime() > currentViewEndTime.getTime() || allDay && result.getHours() < endDayHour) {\r\n            result = currentViewEndTime\r\n        }\r\n        return result\r\n    }\r\n    _fillNormalizedEndDate(dateSettings, rawAppointment) {\r\n        return dateSettings.map(item => {\r\n            var {\r\n                endDate: endDate\r\n            } = item;\r\n            var normalizedEndDate = this.normalizeEndDateByViewEnd(rawAppointment, endDate);\r\n            return _extends(_extends({}, item), {\r\n                normalizedEndDate: normalizedEndDate\r\n            })\r\n        })\r\n    }\r\n    _separateLongParts(gridAppointmentList, appointmentAdapter) {\r\n        var result = [];\r\n        gridAppointmentList.forEach(gridAppointment => {\r\n            var maxDate = new Date(this.dateRange[1]);\r\n            var {\r\n                normalizedEndDate: endDateOfPart\r\n            } = gridAppointment;\r\n            var longStartDateParts = dateUtils.getDatesOfInterval(gridAppointment.startDate, endDateOfPart, {\r\n                milliseconds: this.getIntervalDuration()\r\n            });\r\n            var list = longStartDateParts.filter(startDatePart => new Date(startDatePart) < maxDate).map(date => {\r\n                var endDate = new Date(new Date(date).setMilliseconds(appointmentAdapter.duration));\r\n                var normalizedEndDate = this.normalizeEndDateByViewEnd(this.rawAppointment, endDate);\r\n                return {\r\n                    startDate: date,\r\n                    endDate: endDate,\r\n                    normalizedEndDate: normalizedEndDate,\r\n                    source: gridAppointment.source\r\n                }\r\n            });\r\n            result = result.concat(list)\r\n        });\r\n        return result\r\n    }\r\n    _createGridAppointmentList(appointmentList, appointmentAdapter) {\r\n        return appointmentList.map(source => {\r\n            var offsetDifference = appointmentAdapter.startDate.getTimezoneOffset() - source.startDate.getTimezoneOffset();\r\n            if (0 !== offsetDifference && this._canProcessNotNativeTimezoneDates(appointmentAdapter)) {\r\n                source.startDate = new Date(source.startDate.getTime() + offsetDifference * toMs(\"minute\"));\r\n                source.endDate = new Date(source.endDate.getTime() + offsetDifference * toMs(\"minute\"));\r\n                source.exceptionDate = new Date(source.startDate)\r\n            }\r\n            var startDate = this.timeZoneCalculator.createDate(source.startDate, {\r\n                path: \"toGrid\"\r\n            });\r\n            var endDate = this.timeZoneCalculator.createDate(source.endDate, {\r\n                path: \"toGrid\"\r\n            });\r\n            return {\r\n                startDate: startDate,\r\n                endDate: endDate,\r\n                allDay: appointmentAdapter.allDay || false,\r\n                source: source\r\n            }\r\n        })\r\n    }\r\n    _createExtremeRecurrenceDates(groupIndex) {\r\n        var startViewDate = this.appointmentTakesAllDay ? dateUtils.trimTime(this.dateRange[0]) : this.dateRange[0];\r\n        var endViewDateByEndDayHour = this.dateRange[1];\r\n        if (this.timeZone) {\r\n            startViewDate = this.timeZoneCalculator.createDate(startViewDate, {\r\n                path: \"fromGrid\"\r\n            });\r\n            endViewDateByEndDayHour = this.timeZoneCalculator.createDate(endViewDateByEndDayHour, {\r\n                path: \"fromGrid\"\r\n            });\r\n            var daylightOffset = timeZoneUtils.getDaylightOffsetInMs(startViewDate, endViewDateByEndDayHour);\r\n            if (daylightOffset) {\r\n                endViewDateByEndDayHour = new Date(endViewDateByEndDayHour.getTime() + daylightOffset)\r\n            }\r\n        }\r\n        return [startViewDate, endViewDateByEndDayHour]\r\n    }\r\n    _createRecurrenceOptions(appointment, groupIndex) {\r\n        var [minRecurrenceDate, maxRecurrenceDate] = this._createExtremeRecurrenceDates(groupIndex);\r\n        return {\r\n            rule: appointment.recurrenceRule,\r\n            exception: appointment.recurrenceException,\r\n            min: minRecurrenceDate,\r\n            max: maxRecurrenceDate,\r\n            firstDayOfWeek: this.firstDayOfWeek,\r\n            start: appointment.startDate,\r\n            end: appointment.endDate,\r\n            appointmentTimezoneOffset: this.timeZoneCalculator.getOriginStartDateOffsetInMs(appointment.startDate, appointment.rawAppointment.startDateTimeZone, true),\r\n            getPostProcessedException: date => {\r\n                if (isEmptyObject(this.timeZone) || timeZoneUtils.isEqualLocalTimeZone(this.timeZone, date)) {\r\n                    return date\r\n                }\r\n                var appointmentOffset = this.timeZoneCalculator.getOffsets(appointment.startDate).common;\r\n                var exceptionAppointmentOffset = this.timeZoneCalculator.getOffsets(date).common;\r\n                var diff = appointmentOffset - exceptionAppointmentOffset;\r\n                diff = this._getProcessedNotNativeDateIfCrossDST(date, diff);\r\n                return new Date(date.getTime() - diff * dateUtils.dateToMilliseconds(\"hour\"))\r\n            }\r\n        }\r\n    }\r\n    _createRecurrenceAppointments(appointment, groupIndices) {\r\n        var {\r\n            duration: duration\r\n        } = appointment;\r\n        var option = this._createRecurrenceOptions(appointment);\r\n        var generatedStartDates = getRecurrenceProcessor().generateDates(option);\r\n        return generatedStartDates.map(date => {\r\n            var utcDate = timeZoneUtils.createUTCDateWithLocalOffset(date);\r\n            utcDate.setTime(utcDate.getTime() + duration);\r\n            var endDate = timeZoneUtils.createDateFromUTCWithLocalOffset(utcDate);\r\n            return {\r\n                startDate: new Date(date),\r\n                endDate: endDate\r\n            }\r\n        })\r\n    }\r\n    _getAppointmentsFirstViewDate(appointments) {\r\n        return appointments.map(appointment => this._getAppointmentFirstViewDate(appointment))\r\n    }\r\n    _fillNormalizedStartDate(appointments, firstViewDates, rawAppointment) {\r\n        appointments.forEach((appointment, idx) => {\r\n            appointment.startDate = this._getAppointmentResultDate({\r\n                appointment: appointment,\r\n                rawAppointment: rawAppointment,\r\n                startDate: new Date(appointment.startDate),\r\n                startDayHour: this.viewStartDayHour,\r\n                firstViewDate: firstViewDates[idx]\r\n            })\r\n        })\r\n    }\r\n    _cropAppointmentsByStartDayHour(appointments, firstViewDates) {\r\n        return appointments.filter((appointment, idx) => {\r\n            if (!firstViewDates[idx]) {\r\n                return false\r\n            }\r\n            if (this.appointmentTakesAllDay) {\r\n                return true\r\n            }\r\n            return appointment.endDate > appointment.startDate\r\n        })\r\n    }\r\n    _getAppointmentResultDate(options) {\r\n        var {\r\n            appointment: appointment,\r\n            startDayHour: startDayHour,\r\n            firstViewDate: firstViewDate\r\n        } = options;\r\n        var {\r\n            startDate: startDate\r\n        } = options;\r\n        var resultDate;\r\n        if (this.appointmentTakesAllDay) {\r\n            resultDate = dateUtils.normalizeDate(startDate, firstViewDate)\r\n        } else {\r\n            if (startDate < firstViewDate) {\r\n                startDate = firstViewDate\r\n            }\r\n            resultDate = dateUtils.normalizeDate(appointment.startDate, startDate)\r\n        }\r\n        return !this.isDateAppointment ? dateUtils.roundDateByStartDayHour(resultDate, startDayHour) : resultDate\r\n    }\r\n    _getAppointmentFirstViewDate(appointment) {\r\n        var groupIndex = appointment.source.groupIndex || 0;\r\n        var {\r\n            startDate: startDate,\r\n            endDate: endDate\r\n        } = appointment;\r\n        if (this.isAllDayRowAppointment || appointment.allDay) {\r\n            return this.viewDataProvider.findAllDayGroupCellStartDate(groupIndex, startDate)\r\n        }\r\n        return this.viewDataProvider.findGroupCellStartDate(groupIndex, startDate, endDate, this.isDateAppointment)\r\n    }\r\n    _getGroupIndices(rawAppointment) {\r\n        var result = [];\r\n        if (rawAppointment && this.loadedResources.length) {\r\n            var tree = createResourcesTree(this.loadedResources);\r\n            result = getResourceTreeLeaves((field, action) => getDataAccessors(this.options.dataAccessors.resources, field, action), tree, rawAppointment)\r\n        }\r\n        return result\r\n    }\r\n}\r\nexport class DateGeneratorVirtualStrategy extends DateGeneratorBaseStrategy {\r\n    get groupCount() {\r\n        return getGroupCount(this.loadedResources)\r\n    }\r\n    _createRecurrenceAppointments(appointment, groupIndices) {\r\n        var {\r\n            duration: duration\r\n        } = appointment;\r\n        var result = [];\r\n        var validGroupIndices = this.groupCount ? groupIndices : [0];\r\n        validGroupIndices.forEach(groupIndex => {\r\n            var option = this._createRecurrenceOptions(appointment, groupIndex);\r\n            var generatedStartDates = getRecurrenceProcessor().generateDates(option);\r\n            var recurrentInfo = generatedStartDates.map(date => {\r\n                var startDate = new Date(date);\r\n                var utcDate = timeZoneUtils.createUTCDateWithLocalOffset(date);\r\n                utcDate.setTime(utcDate.getTime() + duration);\r\n                var endDate = timeZoneUtils.createDateFromUTCWithLocalOffset(utcDate);\r\n                return {\r\n                    startDate: startDate,\r\n                    endDate: endDate,\r\n                    groupIndex: groupIndex\r\n                }\r\n            });\r\n            result.push(...recurrentInfo)\r\n        });\r\n        return result\r\n    }\r\n    _updateGroupIndices(appointments, groupIndices) {\r\n        var result = [];\r\n        groupIndices.forEach(groupIndex => {\r\n            var groupStartDate = this.viewDataProvider.getGroupStartDate(groupIndex);\r\n            if (groupStartDate) {\r\n                appointments.forEach(appointment => {\r\n                    var appointmentCopy = extend({}, appointment);\r\n                    appointmentCopy.groupIndex = groupIndex;\r\n                    result.push(appointmentCopy)\r\n                })\r\n            }\r\n        });\r\n        return result\r\n    }\r\n    _getGroupIndices(resources) {\r\n        var groupIndices = super._getGroupIndices(resources);\r\n        var viewDataGroupIndices = this.viewDataProvider.getGroupIndices();\r\n        if (!(null === groupIndices || void 0 === groupIndices ? void 0 : groupIndices.length)) {\r\n            groupIndices = [0]\r\n        }\r\n        return groupIndices.filter(groupIndex => -1 !== viewDataGroupIndices.indexOf(groupIndex))\r\n    }\r\n    _createAppointments(appointment, groupIndices) {\r\n        var appointments = super._createAppointments(appointment, groupIndices);\r\n        return !appointment.isRecurrent ? this._updateGroupIndices(appointments, groupIndices) : appointments\r\n    }\r\n}\r\nexport class AppointmentSettingsGenerator {\r\n    constructor(options) {\r\n        this.options = options;\r\n        this.appointmentAdapter = createAppointmentAdapter(this.rawAppointment, this.dataAccessors, this.timeZoneCalculator)\r\n    }\r\n    get rawAppointment() {\r\n        return this.options.rawAppointment\r\n    }\r\n    get dataAccessors() {\r\n        return this.options.dataAccessors\r\n    }\r\n    get timeZoneCalculator() {\r\n        return this.options.timeZoneCalculator\r\n    }\r\n    get isAllDayRowAppointment() {\r\n        return this.options.appointmentTakesAllDay && this.options.supportAllDayRow\r\n    }\r\n    get groups() {\r\n        return this.options.groups\r\n    }\r\n    get dateSettingsStrategy() {\r\n        var options = _extends(_extends({}, this.options), {\r\n            isAllDayRowAppointment: this.isAllDayRowAppointment\r\n        });\r\n        return this.options.isVirtualScrolling ? new DateGeneratorVirtualStrategy(options) : new DateGeneratorBaseStrategy(options)\r\n    }\r\n    create() {\r\n        var {\r\n            dateSettings: dateSettings,\r\n            itemGroupIndices: itemGroupIndices,\r\n            isRecurrent: isRecurrent\r\n        } = this._generateDateSettings();\r\n        var cellPositions = this._calculateCellPositions(dateSettings, itemGroupIndices);\r\n        var result = this._prepareAppointmentInfos(dateSettings, cellPositions, isRecurrent);\r\n        return result\r\n    }\r\n    _generateDateSettings() {\r\n        return this.dateSettingsStrategy.generate(this.appointmentAdapter)\r\n    }\r\n    _calculateCellPositions(dateSettings, itemGroupIndices) {\r\n        var cellPositionCalculator = new CellPositionCalculator(_extends(_extends({}, this.options), {\r\n            dateSettings: dateSettings\r\n        }));\r\n        return cellPositionCalculator.calculateCellPositions(itemGroupIndices, this.isAllDayRowAppointment, this.appointmentAdapter.isRecurrent)\r\n    }\r\n    _prepareAppointmentInfos(dateSettings, cellPositions, isRecurrent) {\r\n        var infos = [];\r\n        cellPositions.forEach(_ref => {\r\n            var {\r\n                coordinates: coordinates,\r\n                dateSettingIndex: dateSettingIndex\r\n            } = _ref;\r\n            var dateSetting = dateSettings[dateSettingIndex];\r\n            var dateText = this._getAppointmentDateText(dateSetting);\r\n            var info = {\r\n                appointment: dateSetting,\r\n                sourceAppointment: dateSetting.source,\r\n                dateText: dateText,\r\n                isRecurrent: isRecurrent\r\n            };\r\n            infos.push(_extends(_extends({}, coordinates), {\r\n                info: info\r\n            }))\r\n        });\r\n        return infos\r\n    }\r\n    _getAppointmentDateText(sourceAppointment) {\r\n        var {\r\n            startDate: startDate,\r\n            endDate: endDate,\r\n            allDay: allDay\r\n        } = sourceAppointment;\r\n        return createFormattedDateText({\r\n            startDate: startDate,\r\n            endDate: endDate,\r\n            allDay: allDay,\r\n            format: APPOINTMENT_DATE_TEXT_FORMAT\r\n        })\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}