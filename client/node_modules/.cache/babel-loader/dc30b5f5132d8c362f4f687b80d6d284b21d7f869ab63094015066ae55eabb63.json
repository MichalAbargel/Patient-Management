{"ast":null,"code":"/**\r\n * DevExtreme (esm/ui/scheduler/workspaces/view_model/view_data_generator.js)\r\n * Version: 23.1.5\r\n * Build date: Wed Aug 30 2023\r\n *\r\n * Copyright (c) 2012 - 2023 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport dateUtils from \"../../../../core/utils/date\";\nimport { HORIZONTAL_GROUP_ORIENTATION } from \"../../constants\";\nimport { getAllGroups, getGroupCount } from \"../../../../__internal/scheduler/resources/m_utils\";\nimport { calculateCellIndex, calculateDayDuration, isHorizontalView, getStartViewDateWithoutDST, getDisplayedRowCount, getTotalCellCountByCompleteData, getTotalRowCountByCompleteData, getDisplayedCellCount } from \"../../../../renovation/ui/scheduler/view_model/to_test/views/utils/base\";\nimport { getIsGroupedAllDayPanel, getKeyByGroup } from \"../../../../renovation/ui/scheduler/workspaces/utils\";\nvar HOUR_MS = dateUtils.dateToMilliseconds(\"hour\");\nvar DAY_MS = dateUtils.dateToMilliseconds(\"day\");\nexport class ViewDataGenerator {\n  get daysInInterval() {\n    return 1;\n  }\n  get isWorkView() {\n    return false;\n  }\n  get tableAllDay() {\n    return false;\n  }\n  isSkippedDate() {\n    return false;\n  }\n  getStartViewDate(options) {\n    return this._calculateStartViewDate(options);\n  }\n  getCompleteViewDataMap(options) {\n    var {\n      groups: groups,\n      isGroupedByDate: isGroupedByDate,\n      isHorizontalGrouping: isHorizontalGrouping,\n      isVerticalGrouping: isVerticalGrouping,\n      intervalCount: intervalCount,\n      currentDate: currentDate,\n      viewType: viewType,\n      startDayHour: startDayHour,\n      endDayHour: endDayHour,\n      hoursInterval: hoursInterval\n    } = options;\n    this._setVisibilityDates(options);\n    this.setHiddenInterval(startDayHour, endDayHour, hoursInterval);\n    var groupsList = getAllGroups(groups);\n    var cellCountInGroupRow = this.getCellCount({\n      intervalCount: intervalCount,\n      currentDate: currentDate,\n      viewType: viewType,\n      startDayHour: startDayHour,\n      endDayHour: endDayHour,\n      hoursInterval: hoursInterval\n    });\n    var rowCountInGroup = this.getRowCount({\n      intervalCount: intervalCount,\n      currentDate: currentDate,\n      viewType: viewType,\n      hoursInterval: hoursInterval,\n      startDayHour: startDayHour,\n      endDayHour: endDayHour\n    });\n    var viewDataMap = [];\n    var allDayPanelData = this._generateAllDayPanelData(options, rowCountInGroup, cellCountInGroupRow);\n    var viewCellsData = this._generateViewCellsData(options, rowCountInGroup, cellCountInGroupRow);\n    allDayPanelData && viewDataMap.push(allDayPanelData);\n    viewDataMap.push(...viewCellsData);\n    if (isHorizontalGrouping && !isGroupedByDate) {\n      viewDataMap = this._transformViewDataMapForHorizontalGrouping(viewDataMap, groupsList);\n    }\n    if (isVerticalGrouping) {\n      viewDataMap = this._transformViewDataMapForVerticalGrouping(viewDataMap, groupsList);\n    }\n    if (isGroupedByDate) {\n      viewDataMap = this._transformViewDataMapForGroupingByDate(viewDataMap, groupsList);\n    }\n    var completeViewDataMap = this._addKeysToCells(viewDataMap);\n    return completeViewDataMap;\n  }\n  _transformViewDataMapForHorizontalGrouping(viewDataMap, groupsList) {\n    var result = viewDataMap.map(row => row.slice());\n    groupsList.slice(1).forEach((groups, index) => {\n      var groupIndex = index + 1;\n      viewDataMap.forEach((row, rowIndex) => {\n        var nextGroupRow = row.map(cellData => _extends({}, cellData, {\n          groups: groups,\n          groupIndex: groupIndex\n        }));\n        result[rowIndex].push(...nextGroupRow);\n      });\n    });\n    return result;\n  }\n  _transformViewDataMapForVerticalGrouping(viewDataMap, groupsList) {\n    var result = viewDataMap.map(row => row.slice());\n    groupsList.slice(1).forEach((groups, index) => {\n      var groupIndex = index + 1;\n      var nextGroupMap = viewDataMap.map(cellsRow => {\n        var nextRow = cellsRow.map(cellData => _extends({}, cellData, {\n          groupIndex: groupIndex,\n          groups: groups\n        }));\n        return nextRow;\n      });\n      result.push(...nextGroupMap);\n    });\n    return result;\n  }\n  _transformViewDataMapForGroupingByDate(viewDataMap, groupsList) {\n    var correctedGroupList = groupsList.slice(1);\n    var correctedGroupCount = correctedGroupList.length;\n    var result = viewDataMap.map(cellsRow => {\n      var groupedByDateCellsRow = cellsRow.reduce((currentRow, cell) => {\n        var rowWithCurrentCell = [...currentRow, _extends({}, cell, {\n          isFirstGroupCell: true,\n          isLastGroupCell: 0 === correctedGroupCount\n        }), ...correctedGroupList.map((groups, index) => _extends({}, cell, {\n          groups: groups,\n          groupIndex: index + 1,\n          isFirstGroupCell: false,\n          isLastGroupCell: index === correctedGroupCount - 1\n        }))];\n        return rowWithCurrentCell;\n      }, []);\n      return groupedByDateCellsRow;\n    });\n    return result;\n  }\n  _addKeysToCells(viewDataMap) {\n    var totalColumnCount = viewDataMap[0].length;\n    var {\n      currentViewDataMap: result\n    } = viewDataMap.reduce((_ref, row, rowIndex) => {\n      var {\n        allDayPanelsCount: allDayPanelsCount,\n        currentViewDataMap: currentViewDataMap\n      } = _ref;\n      var isAllDay = row[0].allDay;\n      var keyBase = (rowIndex - allDayPanelsCount) * totalColumnCount;\n      var currentAllDayPanelsCount = isAllDay ? allDayPanelsCount + 1 : allDayPanelsCount;\n      currentViewDataMap[rowIndex].forEach((cell, columnIndex) => {\n        cell.key = keyBase + columnIndex;\n      });\n      return {\n        allDayPanelsCount: currentAllDayPanelsCount,\n        currentViewDataMap: currentViewDataMap\n      };\n    }, {\n      allDayPanelsCount: 0,\n      currentViewDataMap: viewDataMap\n    });\n    return result;\n  }\n  generateViewDataMap(completeViewDataMap, options) {\n    var {\n      rowCount: rowCount,\n      startCellIndex: startCellIndex,\n      startRowIndex: startRowIndex,\n      cellCount: cellCount,\n      isVerticalGrouping: isVerticalGrouping,\n      isAllDayPanelVisible: isAllDayPanelVisible\n    } = options;\n    var sliceCells = (row, rowIndex, startIndex, count) => {\n      var sliceToIndex = void 0 !== count ? startIndex + count : void 0;\n      return row.slice(startIndex, sliceToIndex).map((cellData, columnIndex) => ({\n        cellData: cellData,\n        position: {\n          rowIndex: rowIndex,\n          columnIndex: columnIndex\n        }\n      }));\n    };\n    var correctedStartRowIndex = startRowIndex;\n    var allDayPanelMap = [];\n    if (this._isStandaloneAllDayPanel(isVerticalGrouping, isAllDayPanelVisible)) {\n      correctedStartRowIndex++;\n      allDayPanelMap = sliceCells(completeViewDataMap[0], 0, startCellIndex, cellCount);\n    }\n    var displayedRowCount = getDisplayedRowCount(rowCount, completeViewDataMap);\n    var dateTableMap = completeViewDataMap.slice(correctedStartRowIndex, correctedStartRowIndex + displayedRowCount).map((row, rowIndex) => sliceCells(row, rowIndex, startCellIndex, cellCount));\n    return {\n      allDayPanelMap: allDayPanelMap,\n      dateTableMap: dateTableMap\n    };\n  }\n  _isStandaloneAllDayPanel(isVerticalGrouping, isAllDayPanelVisible) {\n    return !isVerticalGrouping && isAllDayPanelVisible;\n  }\n  getViewDataFromMap(completeViewDataMap, viewDataMap, options) {\n    var {\n      topVirtualRowHeight: topVirtualRowHeight,\n      bottomVirtualRowHeight: bottomVirtualRowHeight,\n      leftVirtualCellWidth: leftVirtualCellWidth,\n      rightVirtualCellWidth: rightVirtualCellWidth,\n      cellCount: cellCount,\n      rowCount: rowCount,\n      startRowIndex: startRowIndex,\n      startCellIndex: startCellIndex,\n      isProvideVirtualCellsWidth: isProvideVirtualCellsWidth,\n      isGroupedAllDayPanel: isGroupedAllDayPanel,\n      isVerticalGrouping: isVerticalGrouping,\n      isAllDayPanelVisible: isAllDayPanelVisible\n    } = options;\n    var {\n      allDayPanelMap: allDayPanelMap,\n      dateTableMap: dateTableMap\n    } = viewDataMap;\n    var {\n      groupedData: groupedData\n    } = dateTableMap.reduce((_ref2, cellsRow) => {\n      var {\n        previousGroupIndex: previousGroupIndex,\n        groupedData: groupedData\n      } = _ref2;\n      var cellDataRow = cellsRow.map(_ref3 => {\n        var {\n          cellData: cellData\n        } = _ref3;\n        return cellData;\n      });\n      var firstCell = cellDataRow[0];\n      var isAllDayRow = firstCell.allDay;\n      var currentGroupIndex = firstCell.groupIndex;\n      if (currentGroupIndex !== previousGroupIndex) {\n        groupedData.push({\n          dateTable: [],\n          isGroupedAllDayPanel: getIsGroupedAllDayPanel(!!isAllDayRow, isVerticalGrouping),\n          groupIndex: currentGroupIndex,\n          key: getKeyByGroup(currentGroupIndex, isVerticalGrouping)\n        });\n      }\n      if (isAllDayRow) {\n        groupedData[groupedData.length - 1].allDayPanel = cellDataRow;\n      } else {\n        groupedData[groupedData.length - 1].dateTable.push({\n          cells: cellDataRow,\n          key: cellDataRow[0].key - startCellIndex\n        });\n      }\n      return {\n        groupedData: groupedData,\n        previousGroupIndex: currentGroupIndex\n      };\n    }, {\n      previousGroupIndex: -1,\n      groupedData: []\n    });\n    if (this._isStandaloneAllDayPanel(isVerticalGrouping, isAllDayPanelVisible)) {\n      groupedData[0].allDayPanel = allDayPanelMap.map(_ref4 => {\n        var {\n          cellData: cellData\n        } = _ref4;\n        return cellData;\n      });\n    }\n    var totalCellCount = getTotalCellCountByCompleteData(completeViewDataMap);\n    var totalRowCount = getTotalRowCountByCompleteData(completeViewDataMap);\n    var displayedCellCount = getDisplayedCellCount(cellCount, completeViewDataMap);\n    var displayedRowCount = getDisplayedRowCount(rowCount, completeViewDataMap);\n    return {\n      groupedData: groupedData,\n      topVirtualRowHeight: topVirtualRowHeight,\n      bottomVirtualRowHeight: bottomVirtualRowHeight,\n      leftVirtualCellWidth: isProvideVirtualCellsWidth ? leftVirtualCellWidth : void 0,\n      rightVirtualCellWidth: isProvideVirtualCellsWidth ? rightVirtualCellWidth : void 0,\n      isGroupedAllDayPanel: isGroupedAllDayPanel,\n      leftVirtualCellCount: startCellIndex,\n      rightVirtualCellCount: void 0 === cellCount ? 0 : totalCellCount - startCellIndex - displayedCellCount,\n      topVirtualRowCount: startRowIndex,\n      bottomVirtualRowCount: totalRowCount - startRowIndex - displayedRowCount\n    };\n  }\n  _generateViewCellsData(options, rowCount, cellCountInGroupRow) {\n    var viewCellsData = [];\n    for (var rowIndex = 0; rowIndex < rowCount; rowIndex += 1) {\n      viewCellsData.push(this._generateCellsRow(options, false, rowIndex, rowCount, cellCountInGroupRow));\n    }\n    return viewCellsData;\n  }\n  _generateAllDayPanelData(options, rowCount, columnCount) {\n    if (!options.isAllDayPanelVisible) {\n      return null;\n    }\n    return this._generateCellsRow(options, true, 0, rowCount, columnCount);\n  }\n  _generateCellsRow(options, allDay, rowIndex, rowCount, columnCount) {\n    var cellsRow = [];\n    for (var columnIndex = 0; columnIndex < columnCount; ++columnIndex) {\n      var cellDataValue = this.getCellData(rowIndex, columnIndex, options, allDay);\n      cellDataValue.index = rowIndex * columnCount + columnIndex;\n      cellDataValue.isFirstGroupCell = this._isFirstGroupCell(rowIndex, columnIndex, options, rowCount, columnCount);\n      cellDataValue.isLastGroupCell = this._isLastGroupCell(rowIndex, columnIndex, options, rowCount, columnCount);\n      cellsRow.push(cellDataValue);\n    }\n    return cellsRow;\n  }\n  getCellData(rowIndex, columnIndex, options, allDay) {\n    return allDay ? this.prepareAllDayCellData(options, rowIndex, columnIndex) : this.prepareCellData(options, rowIndex, columnIndex);\n  }\n  prepareCellData(options, rowIndex, columnIndex) {\n    var {\n      groups: groups,\n      startDayHour: startDayHour,\n      endDayHour: endDayHour,\n      interval: interval,\n      hoursInterval: hoursInterval\n    } = options;\n    var groupsList = getAllGroups(groups);\n    var startDate = this.getDateByCellIndices(options, rowIndex, columnIndex, this.getCellCountInDay(startDayHour, endDayHour, hoursInterval));\n    var endDate = this.calculateEndDate(startDate, interval, endDayHour);\n    var data = {\n      startDate: startDate,\n      endDate: endDate,\n      allDay: this.tableAllDay,\n      groupIndex: 0\n    };\n    if (groupsList.length > 0) {\n      data.groups = groupsList[0];\n    }\n    return data;\n  }\n  prepareAllDayCellData(options, rowIndex, columnIndex) {\n    var data = this.prepareCellData(options, rowIndex, columnIndex);\n    var startDate = dateUtils.trimTime(data.startDate);\n    return _extends({}, data, {\n      startDate: startDate,\n      endDate: startDate,\n      allDay: true\n    });\n  }\n  getDateByCellIndices(options, rowIndex, columnIndex, cellCountInDay) {\n    var startViewDate = options.startViewDate;\n    var {\n      startDayHour: startDayHour,\n      interval: interval,\n      firstDayOfWeek: firstDayOfWeek,\n      intervalCount: intervalCount\n    } = options;\n    var isStartViewDateDuringDST = startViewDate.getHours() !== Math.floor(startDayHour);\n    if (isStartViewDateDuringDST) {\n      var dateWithCorrectHours = getStartViewDateWithoutDST(startViewDate, startDayHour);\n      startViewDate = new Date(dateWithCorrectHours - dateUtils.dateToMilliseconds(\"day\"));\n    }\n    var columnCountBase = this.getCellCount(options);\n    var rowCountBase = this.getRowCount(options);\n    var cellIndex = this._calculateCellIndex(rowIndex, columnIndex, rowCountBase, columnCountBase);\n    var millisecondsOffset = this.getMillisecondsOffset(cellIndex, interval, cellCountInDay);\n    var offsetByCount = this.isWorkView ? this.getTimeOffsetByColumnIndex(columnIndex, this.getFirstDayOfWeek(firstDayOfWeek), columnCountBase, intervalCount) : 0;\n    var startViewDateTime = startViewDate.getTime();\n    var currentDate = new Date(startViewDateTime + millisecondsOffset + offsetByCount);\n    var timeZoneDifference = isStartViewDateDuringDST ? 0 : dateUtils.getTimezonesDifference(startViewDate, currentDate);\n    currentDate.setTime(currentDate.getTime() + timeZoneDifference);\n    return currentDate;\n  }\n  getMillisecondsOffset(cellIndex, interval, cellCountInDay) {\n    var dayIndex = Math.floor(cellIndex / cellCountInDay);\n    var realHiddenInterval = dayIndex * this.hiddenInterval;\n    return interval * cellIndex + realHiddenInterval;\n  }\n  getTimeOffsetByColumnIndex(columnIndex, firstDayOfWeek, columnCount, intervalCount) {\n    var firstDayOfWeekDiff = Math.max(0, firstDayOfWeek - 1);\n    var columnsInWeek = columnCount / intervalCount;\n    var weekendCount = Math.floor((columnIndex + firstDayOfWeekDiff) / columnsInWeek);\n    return DAY_MS * weekendCount * 2;\n  }\n  calculateEndDate(startDate, interval, endDayHour) {\n    var result = new Date(startDate);\n    result.setMilliseconds(result.getMilliseconds() + Math.round(interval));\n    return result;\n  }\n  _calculateCellIndex(rowIndex, columnIndex, rowCount, columnCount) {\n    return calculateCellIndex(rowIndex, columnIndex, rowCount);\n  }\n  generateGroupedDataMap(viewDataMap) {\n    var {\n      allDayPanelMap: allDayPanelMap,\n      dateTableMap: dateTableMap\n    } = viewDataMap;\n    var {\n      previousGroupedDataMap: dateTableGroupedMap\n    } = dateTableMap.reduce((previousOptions, cellsRow) => {\n      var {\n        previousGroupedDataMap: previousGroupedDataMap,\n        previousRowIndex: previousRowIndex,\n        previousGroupIndex: previousGroupIndex\n      } = previousOptions;\n      var {\n        groupIndex: currentGroupIndex\n      } = cellsRow[0].cellData;\n      var currentRowIndex = currentGroupIndex === previousGroupIndex ? previousRowIndex + 1 : 0;\n      cellsRow.forEach(cell => {\n        var {\n          groupIndex: groupIndex\n        } = cell.cellData;\n        if (!previousGroupedDataMap[groupIndex]) {\n          previousGroupedDataMap[groupIndex] = [];\n        }\n        if (!previousGroupedDataMap[groupIndex][currentRowIndex]) {\n          previousGroupedDataMap[groupIndex][currentRowIndex] = [];\n        }\n        previousGroupedDataMap[groupIndex][currentRowIndex].push(cell);\n      });\n      return {\n        previousGroupedDataMap: previousGroupedDataMap,\n        previousRowIndex: currentRowIndex,\n        previousGroupIndex: currentGroupIndex\n      };\n    }, {\n      previousGroupedDataMap: [],\n      previousRowIndex: -1,\n      previousGroupIndex: -1\n    });\n    var allDayPanelGroupedMap = [];\n    null === allDayPanelMap || void 0 === allDayPanelMap ? void 0 : allDayPanelMap.forEach(cell => {\n      var {\n        groupIndex: groupIndex\n      } = cell.cellData;\n      if (!allDayPanelGroupedMap[groupIndex]) {\n        allDayPanelGroupedMap[groupIndex] = [];\n      }\n      allDayPanelGroupedMap[groupIndex].push(cell);\n    });\n    return {\n      allDayPanelGroupedMap: allDayPanelGroupedMap,\n      dateTableGroupedMap: dateTableGroupedMap\n    };\n  }\n  _isFirstGroupCell(rowIndex, columnIndex, options, rowCount, columnCount) {\n    var {\n      groupOrientation: groupOrientation,\n      groups: groups,\n      isGroupedByDate: isGroupedByDate\n    } = options;\n    var groupCount = getGroupCount(groups);\n    if (isGroupedByDate) {\n      return columnIndex % groupCount === 0;\n    }\n    if (groupOrientation === HORIZONTAL_GROUP_ORIENTATION) {\n      return columnIndex % columnCount === 0;\n    }\n    return rowIndex % rowCount === 0;\n  }\n  _isLastGroupCell(rowIndex, columnIndex, options, rowCount, columnCount) {\n    var {\n      groupOrientation: groupOrientation,\n      groups: groups,\n      isGroupedByDate: isGroupedByDate\n    } = options;\n    var groupCount = getGroupCount(groups);\n    if (isGroupedByDate) {\n      return (columnIndex + 1) % groupCount === 0;\n    }\n    if (groupOrientation === HORIZONTAL_GROUP_ORIENTATION) {\n      return (columnIndex + 1) % columnCount === 0;\n    }\n    return (rowIndex + 1) % rowCount === 0;\n  }\n  markSelectedAndFocusedCells(viewDataMap, renderOptions) {\n    var {\n      selectedCells: selectedCells,\n      focusedCell: focusedCell\n    } = renderOptions;\n    if (!selectedCells && !focusedCell) {\n      return viewDataMap;\n    }\n    var {\n      allDayPanelMap: allDayPanelMap,\n      dateTableMap: dateTableMap\n    } = viewDataMap;\n    var nextDateTableMap = dateTableMap.map(row => this._markSelectedAndFocusedCellsInRow(row, selectedCells, focusedCell));\n    var nextAllDayMap = this._markSelectedAndFocusedCellsInRow(allDayPanelMap, selectedCells, focusedCell);\n    return {\n      allDayPanelMap: nextAllDayMap,\n      dateTableMap: nextDateTableMap\n    };\n  }\n  _markSelectedAndFocusedCellsInRow(dataRow, selectedCells, focusedCell) {\n    return dataRow.map(cell => {\n      var {\n        index: index,\n        groupIndex: groupIndex,\n        allDay: allDay,\n        startDate: startDate\n      } = cell.cellData;\n      var indexInSelectedCells = selectedCells.findIndex(_ref5 => {\n        var {\n          index: selectedCellIndex,\n          groupIndex: selectedCellGroupIndex,\n          allDay: selectedCellAllDay,\n          startDate: selectedCellStartDate\n        } = _ref5;\n        return groupIndex === selectedCellGroupIndex && (index === selectedCellIndex || void 0 === selectedCellIndex && startDate.getTime() === selectedCellStartDate.getTime()) && !!allDay === !!selectedCellAllDay;\n      });\n      var isFocused = !!focusedCell && index === focusedCell.cellData.index && groupIndex === focusedCell.cellData.groupIndex && allDay === focusedCell.cellData.allDay;\n      if (!isFocused && -1 === indexInSelectedCells) {\n        return cell;\n      }\n      return _extends({}, cell, {\n        cellData: _extends({}, cell.cellData, {\n          isSelected: indexInSelectedCells > -1,\n          isFocused: isFocused\n        })\n      });\n    });\n  }\n  getInterval(hoursInterval) {\n    return hoursInterval * HOUR_MS;\n  }\n  _getIntervalDuration(intervalCount) {\n    return dateUtils.dateToMilliseconds(\"day\") * intervalCount;\n  }\n  _setVisibilityDates() {}\n  getCellCountInDay(startDayHour, endDayHour, hoursInterval) {\n    var result = calculateDayDuration(startDayHour, endDayHour) / hoursInterval;\n    return Math.ceil(result);\n  }\n  getCellCount(options) {\n    var {\n      intervalCount: intervalCount,\n      viewType: viewType,\n      startDayHour: startDayHour,\n      endDayHour: endDayHour,\n      hoursInterval: hoursInterval\n    } = options;\n    var cellCountInDay = this.getCellCountInDay(startDayHour, endDayHour, hoursInterval);\n    var columnCountInDay = isHorizontalView(viewType) ? cellCountInDay : 1;\n    return this.daysInInterval * intervalCount * columnCountInDay;\n  }\n  getRowCount(options) {\n    var {\n      viewType: viewType,\n      startDayHour: startDayHour,\n      endDayHour: endDayHour,\n      hoursInterval: hoursInterval\n    } = options;\n    var cellCountInDay = this.getCellCountInDay(startDayHour, endDayHour, hoursInterval);\n    var rowCountInDay = !isHorizontalView(viewType) ? cellCountInDay : 1;\n    return rowCountInDay;\n  }\n  setHiddenInterval(startDayHour, endDayHour, hoursInterval) {\n    this.hiddenInterval = DAY_MS - this.getVisibleDayDuration(startDayHour, endDayHour, hoursInterval);\n  }\n  getVisibleDayDuration(startDayHour, endDayHour, hoursInterval) {\n    var cellCountInDay = this.getCellCountInDay(startDayHour, endDayHour, hoursInterval);\n    return hoursInterval * cellCountInDay * HOUR_MS;\n  }\n  getFirstDayOfWeek(firstDayOfWeekOption) {\n    return firstDayOfWeekOption;\n  }\n}","map":{"version":3,"names":["_extends","dateUtils","HORIZONTAL_GROUP_ORIENTATION","getAllGroups","getGroupCount","calculateCellIndex","calculateDayDuration","isHorizontalView","getStartViewDateWithoutDST","getDisplayedRowCount","getTotalCellCountByCompleteData","getTotalRowCountByCompleteData","getDisplayedCellCount","getIsGroupedAllDayPanel","getKeyByGroup","HOUR_MS","dateToMilliseconds","DAY_MS","ViewDataGenerator","daysInInterval","isWorkView","tableAllDay","isSkippedDate","getStartViewDate","options","_calculateStartViewDate","getCompleteViewDataMap","groups","isGroupedByDate","isHorizontalGrouping","isVerticalGrouping","intervalCount","currentDate","viewType","startDayHour","endDayHour","hoursInterval","_setVisibilityDates","setHiddenInterval","groupsList","cellCountInGroupRow","getCellCount","rowCountInGroup","getRowCount","viewDataMap","allDayPanelData","_generateAllDayPanelData","viewCellsData","_generateViewCellsData","push","_transformViewDataMapForHorizontalGrouping","_transformViewDataMapForVerticalGrouping","_transformViewDataMapForGroupingByDate","completeViewDataMap","_addKeysToCells","result","map","row","slice","forEach","index","groupIndex","rowIndex","nextGroupRow","cellData","nextGroupMap","cellsRow","nextRow","correctedGroupList","correctedGroupCount","length","groupedByDateCellsRow","reduce","currentRow","cell","rowWithCurrentCell","isFirstGroupCell","isLastGroupCell","totalColumnCount","currentViewDataMap","_ref","allDayPanelsCount","isAllDay","allDay","keyBase","currentAllDayPanelsCount","columnIndex","key","generateViewDataMap","rowCount","startCellIndex","startRowIndex","cellCount","isAllDayPanelVisible","sliceCells","startIndex","count","sliceToIndex","position","correctedStartRowIndex","allDayPanelMap","_isStandaloneAllDayPanel","displayedRowCount","dateTableMap","getViewDataFromMap","topVirtualRowHeight","bottomVirtualRowHeight","leftVirtualCellWidth","rightVirtualCellWidth","isProvideVirtualCellsWidth","isGroupedAllDayPanel","groupedData","_ref2","previousGroupIndex","cellDataRow","_ref3","firstCell","isAllDayRow","currentGroupIndex","dateTable","allDayPanel","cells","_ref4","totalCellCount","totalRowCount","displayedCellCount","leftVirtualCellCount","rightVirtualCellCount","topVirtualRowCount","bottomVirtualRowCount","_generateCellsRow","columnCount","cellDataValue","getCellData","_isFirstGroupCell","_isLastGroupCell","prepareAllDayCellData","prepareCellData","interval","startDate","getDateByCellIndices","getCellCountInDay","endDate","calculateEndDate","data","trimTime","cellCountInDay","startViewDate","firstDayOfWeek","isStartViewDateDuringDST","getHours","Math","floor","dateWithCorrectHours","Date","columnCountBase","rowCountBase","cellIndex","_calculateCellIndex","millisecondsOffset","getMillisecondsOffset","offsetByCount","getTimeOffsetByColumnIndex","getFirstDayOfWeek","startViewDateTime","getTime","timeZoneDifference","getTimezonesDifference","setTime","dayIndex","realHiddenInterval","hiddenInterval","firstDayOfWeekDiff","max","columnsInWeek","weekendCount","setMilliseconds","getMilliseconds","round","generateGroupedDataMap","previousGroupedDataMap","dateTableGroupedMap","previousOptions","previousRowIndex","currentRowIndex","allDayPanelGroupedMap","groupOrientation","groupCount","markSelectedAndFocusedCells","renderOptions","selectedCells","focusedCell","nextDateTableMap","_markSelectedAndFocusedCellsInRow","nextAllDayMap","dataRow","indexInSelectedCells","findIndex","_ref5","selectedCellIndex","selectedCellGroupIndex","selectedCellAllDay","selectedCellStartDate","isFocused","isSelected","getInterval","_getIntervalDuration","ceil","columnCountInDay","rowCountInDay","getVisibleDayDuration","firstDayOfWeekOption"],"sources":["C:/Users/Michal Abargel/Desktop/FULLSTACK_PROJECTS/Patient-Management/client/node_modules/devextreme/esm/ui/scheduler/workspaces/view_model/view_data_generator.js"],"sourcesContent":["/**\r\n * DevExtreme (esm/ui/scheduler/workspaces/view_model/view_data_generator.js)\r\n * Version: 23.1.5\r\n * Build date: Wed Aug 30 2023\r\n *\r\n * Copyright (c) 2012 - 2023 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\r\nimport dateUtils from \"../../../../core/utils/date\";\r\nimport {\r\n    HORIZONTAL_GROUP_ORIENTATION\r\n} from \"../../constants\";\r\nimport {\r\n    getAllGroups,\r\n    getGroupCount\r\n} from \"../../../../__internal/scheduler/resources/m_utils\";\r\nimport {\r\n    calculateCellIndex,\r\n    calculateDayDuration,\r\n    isHorizontalView,\r\n    getStartViewDateWithoutDST,\r\n    getDisplayedRowCount,\r\n    getTotalCellCountByCompleteData,\r\n    getTotalRowCountByCompleteData,\r\n    getDisplayedCellCount\r\n} from \"../../../../renovation/ui/scheduler/view_model/to_test/views/utils/base\";\r\nimport {\r\n    getIsGroupedAllDayPanel,\r\n    getKeyByGroup\r\n} from \"../../../../renovation/ui/scheduler/workspaces/utils\";\r\nvar HOUR_MS = dateUtils.dateToMilliseconds(\"hour\");\r\nvar DAY_MS = dateUtils.dateToMilliseconds(\"day\");\r\nexport class ViewDataGenerator {\r\n    get daysInInterval() {\r\n        return 1\r\n    }\r\n    get isWorkView() {\r\n        return false\r\n    }\r\n    get tableAllDay() {\r\n        return false\r\n    }\r\n    isSkippedDate() {\r\n        return false\r\n    }\r\n    getStartViewDate(options) {\r\n        return this._calculateStartViewDate(options)\r\n    }\r\n    getCompleteViewDataMap(options) {\r\n        var {\r\n            groups: groups,\r\n            isGroupedByDate: isGroupedByDate,\r\n            isHorizontalGrouping: isHorizontalGrouping,\r\n            isVerticalGrouping: isVerticalGrouping,\r\n            intervalCount: intervalCount,\r\n            currentDate: currentDate,\r\n            viewType: viewType,\r\n            startDayHour: startDayHour,\r\n            endDayHour: endDayHour,\r\n            hoursInterval: hoursInterval\r\n        } = options;\r\n        this._setVisibilityDates(options);\r\n        this.setHiddenInterval(startDayHour, endDayHour, hoursInterval);\r\n        var groupsList = getAllGroups(groups);\r\n        var cellCountInGroupRow = this.getCellCount({\r\n            intervalCount: intervalCount,\r\n            currentDate: currentDate,\r\n            viewType: viewType,\r\n            startDayHour: startDayHour,\r\n            endDayHour: endDayHour,\r\n            hoursInterval: hoursInterval\r\n        });\r\n        var rowCountInGroup = this.getRowCount({\r\n            intervalCount: intervalCount,\r\n            currentDate: currentDate,\r\n            viewType: viewType,\r\n            hoursInterval: hoursInterval,\r\n            startDayHour: startDayHour,\r\n            endDayHour: endDayHour\r\n        });\r\n        var viewDataMap = [];\r\n        var allDayPanelData = this._generateAllDayPanelData(options, rowCountInGroup, cellCountInGroupRow);\r\n        var viewCellsData = this._generateViewCellsData(options, rowCountInGroup, cellCountInGroupRow);\r\n        allDayPanelData && viewDataMap.push(allDayPanelData);\r\n        viewDataMap.push(...viewCellsData);\r\n        if (isHorizontalGrouping && !isGroupedByDate) {\r\n            viewDataMap = this._transformViewDataMapForHorizontalGrouping(viewDataMap, groupsList)\r\n        }\r\n        if (isVerticalGrouping) {\r\n            viewDataMap = this._transformViewDataMapForVerticalGrouping(viewDataMap, groupsList)\r\n        }\r\n        if (isGroupedByDate) {\r\n            viewDataMap = this._transformViewDataMapForGroupingByDate(viewDataMap, groupsList)\r\n        }\r\n        var completeViewDataMap = this._addKeysToCells(viewDataMap);\r\n        return completeViewDataMap\r\n    }\r\n    _transformViewDataMapForHorizontalGrouping(viewDataMap, groupsList) {\r\n        var result = viewDataMap.map(row => row.slice());\r\n        groupsList.slice(1).forEach((groups, index) => {\r\n            var groupIndex = index + 1;\r\n            viewDataMap.forEach((row, rowIndex) => {\r\n                var nextGroupRow = row.map(cellData => _extends({}, cellData, {\r\n                    groups: groups,\r\n                    groupIndex: groupIndex\r\n                }));\r\n                result[rowIndex].push(...nextGroupRow)\r\n            })\r\n        });\r\n        return result\r\n    }\r\n    _transformViewDataMapForVerticalGrouping(viewDataMap, groupsList) {\r\n        var result = viewDataMap.map(row => row.slice());\r\n        groupsList.slice(1).forEach((groups, index) => {\r\n            var groupIndex = index + 1;\r\n            var nextGroupMap = viewDataMap.map(cellsRow => {\r\n                var nextRow = cellsRow.map(cellData => _extends({}, cellData, {\r\n                    groupIndex: groupIndex,\r\n                    groups: groups\r\n                }));\r\n                return nextRow\r\n            });\r\n            result.push(...nextGroupMap)\r\n        });\r\n        return result\r\n    }\r\n    _transformViewDataMapForGroupingByDate(viewDataMap, groupsList) {\r\n        var correctedGroupList = groupsList.slice(1);\r\n        var correctedGroupCount = correctedGroupList.length;\r\n        var result = viewDataMap.map(cellsRow => {\r\n            var groupedByDateCellsRow = cellsRow.reduce((currentRow, cell) => {\r\n                var rowWithCurrentCell = [...currentRow, _extends({}, cell, {\r\n                    isFirstGroupCell: true,\r\n                    isLastGroupCell: 0 === correctedGroupCount\r\n                }), ...correctedGroupList.map((groups, index) => _extends({}, cell, {\r\n                    groups: groups,\r\n                    groupIndex: index + 1,\r\n                    isFirstGroupCell: false,\r\n                    isLastGroupCell: index === correctedGroupCount - 1\r\n                }))];\r\n                return rowWithCurrentCell\r\n            }, []);\r\n            return groupedByDateCellsRow\r\n        });\r\n        return result\r\n    }\r\n    _addKeysToCells(viewDataMap) {\r\n        var totalColumnCount = viewDataMap[0].length;\r\n        var {\r\n            currentViewDataMap: result\r\n        } = viewDataMap.reduce((_ref, row, rowIndex) => {\r\n            var {\r\n                allDayPanelsCount: allDayPanelsCount,\r\n                currentViewDataMap: currentViewDataMap\r\n            } = _ref;\r\n            var isAllDay = row[0].allDay;\r\n            var keyBase = (rowIndex - allDayPanelsCount) * totalColumnCount;\r\n            var currentAllDayPanelsCount = isAllDay ? allDayPanelsCount + 1 : allDayPanelsCount;\r\n            currentViewDataMap[rowIndex].forEach((cell, columnIndex) => {\r\n                cell.key = keyBase + columnIndex\r\n            });\r\n            return {\r\n                allDayPanelsCount: currentAllDayPanelsCount,\r\n                currentViewDataMap: currentViewDataMap\r\n            }\r\n        }, {\r\n            allDayPanelsCount: 0,\r\n            currentViewDataMap: viewDataMap\r\n        });\r\n        return result\r\n    }\r\n    generateViewDataMap(completeViewDataMap, options) {\r\n        var {\r\n            rowCount: rowCount,\r\n            startCellIndex: startCellIndex,\r\n            startRowIndex: startRowIndex,\r\n            cellCount: cellCount,\r\n            isVerticalGrouping: isVerticalGrouping,\r\n            isAllDayPanelVisible: isAllDayPanelVisible\r\n        } = options;\r\n        var sliceCells = (row, rowIndex, startIndex, count) => {\r\n            var sliceToIndex = void 0 !== count ? startIndex + count : void 0;\r\n            return row.slice(startIndex, sliceToIndex).map((cellData, columnIndex) => ({\r\n                cellData: cellData,\r\n                position: {\r\n                    rowIndex: rowIndex,\r\n                    columnIndex: columnIndex\r\n                }\r\n            }))\r\n        };\r\n        var correctedStartRowIndex = startRowIndex;\r\n        var allDayPanelMap = [];\r\n        if (this._isStandaloneAllDayPanel(isVerticalGrouping, isAllDayPanelVisible)) {\r\n            correctedStartRowIndex++;\r\n            allDayPanelMap = sliceCells(completeViewDataMap[0], 0, startCellIndex, cellCount)\r\n        }\r\n        var displayedRowCount = getDisplayedRowCount(rowCount, completeViewDataMap);\r\n        var dateTableMap = completeViewDataMap.slice(correctedStartRowIndex, correctedStartRowIndex + displayedRowCount).map((row, rowIndex) => sliceCells(row, rowIndex, startCellIndex, cellCount));\r\n        return {\r\n            allDayPanelMap: allDayPanelMap,\r\n            dateTableMap: dateTableMap\r\n        }\r\n    }\r\n    _isStandaloneAllDayPanel(isVerticalGrouping, isAllDayPanelVisible) {\r\n        return !isVerticalGrouping && isAllDayPanelVisible\r\n    }\r\n    getViewDataFromMap(completeViewDataMap, viewDataMap, options) {\r\n        var {\r\n            topVirtualRowHeight: topVirtualRowHeight,\r\n            bottomVirtualRowHeight: bottomVirtualRowHeight,\r\n            leftVirtualCellWidth: leftVirtualCellWidth,\r\n            rightVirtualCellWidth: rightVirtualCellWidth,\r\n            cellCount: cellCount,\r\n            rowCount: rowCount,\r\n            startRowIndex: startRowIndex,\r\n            startCellIndex: startCellIndex,\r\n            isProvideVirtualCellsWidth: isProvideVirtualCellsWidth,\r\n            isGroupedAllDayPanel: isGroupedAllDayPanel,\r\n            isVerticalGrouping: isVerticalGrouping,\r\n            isAllDayPanelVisible: isAllDayPanelVisible\r\n        } = options;\r\n        var {\r\n            allDayPanelMap: allDayPanelMap,\r\n            dateTableMap: dateTableMap\r\n        } = viewDataMap;\r\n        var {\r\n            groupedData: groupedData\r\n        } = dateTableMap.reduce((_ref2, cellsRow) => {\r\n            var {\r\n                previousGroupIndex: previousGroupIndex,\r\n                groupedData: groupedData\r\n            } = _ref2;\r\n            var cellDataRow = cellsRow.map(_ref3 => {\r\n                var {\r\n                    cellData: cellData\r\n                } = _ref3;\r\n                return cellData\r\n            });\r\n            var firstCell = cellDataRow[0];\r\n            var isAllDayRow = firstCell.allDay;\r\n            var currentGroupIndex = firstCell.groupIndex;\r\n            if (currentGroupIndex !== previousGroupIndex) {\r\n                groupedData.push({\r\n                    dateTable: [],\r\n                    isGroupedAllDayPanel: getIsGroupedAllDayPanel(!!isAllDayRow, isVerticalGrouping),\r\n                    groupIndex: currentGroupIndex,\r\n                    key: getKeyByGroup(currentGroupIndex, isVerticalGrouping)\r\n                })\r\n            }\r\n            if (isAllDayRow) {\r\n                groupedData[groupedData.length - 1].allDayPanel = cellDataRow\r\n            } else {\r\n                groupedData[groupedData.length - 1].dateTable.push({\r\n                    cells: cellDataRow,\r\n                    key: cellDataRow[0].key - startCellIndex\r\n                })\r\n            }\r\n            return {\r\n                groupedData: groupedData,\r\n                previousGroupIndex: currentGroupIndex\r\n            }\r\n        }, {\r\n            previousGroupIndex: -1,\r\n            groupedData: []\r\n        });\r\n        if (this._isStandaloneAllDayPanel(isVerticalGrouping, isAllDayPanelVisible)) {\r\n            groupedData[0].allDayPanel = allDayPanelMap.map(_ref4 => {\r\n                var {\r\n                    cellData: cellData\r\n                } = _ref4;\r\n                return cellData\r\n            })\r\n        }\r\n        var totalCellCount = getTotalCellCountByCompleteData(completeViewDataMap);\r\n        var totalRowCount = getTotalRowCountByCompleteData(completeViewDataMap);\r\n        var displayedCellCount = getDisplayedCellCount(cellCount, completeViewDataMap);\r\n        var displayedRowCount = getDisplayedRowCount(rowCount, completeViewDataMap);\r\n        return {\r\n            groupedData: groupedData,\r\n            topVirtualRowHeight: topVirtualRowHeight,\r\n            bottomVirtualRowHeight: bottomVirtualRowHeight,\r\n            leftVirtualCellWidth: isProvideVirtualCellsWidth ? leftVirtualCellWidth : void 0,\r\n            rightVirtualCellWidth: isProvideVirtualCellsWidth ? rightVirtualCellWidth : void 0,\r\n            isGroupedAllDayPanel: isGroupedAllDayPanel,\r\n            leftVirtualCellCount: startCellIndex,\r\n            rightVirtualCellCount: void 0 === cellCount ? 0 : totalCellCount - startCellIndex - displayedCellCount,\r\n            topVirtualRowCount: startRowIndex,\r\n            bottomVirtualRowCount: totalRowCount - startRowIndex - displayedRowCount\r\n        }\r\n    }\r\n    _generateViewCellsData(options, rowCount, cellCountInGroupRow) {\r\n        var viewCellsData = [];\r\n        for (var rowIndex = 0; rowIndex < rowCount; rowIndex += 1) {\r\n            viewCellsData.push(this._generateCellsRow(options, false, rowIndex, rowCount, cellCountInGroupRow))\r\n        }\r\n        return viewCellsData\r\n    }\r\n    _generateAllDayPanelData(options, rowCount, columnCount) {\r\n        if (!options.isAllDayPanelVisible) {\r\n            return null\r\n        }\r\n        return this._generateCellsRow(options, true, 0, rowCount, columnCount)\r\n    }\r\n    _generateCellsRow(options, allDay, rowIndex, rowCount, columnCount) {\r\n        var cellsRow = [];\r\n        for (var columnIndex = 0; columnIndex < columnCount; ++columnIndex) {\r\n            var cellDataValue = this.getCellData(rowIndex, columnIndex, options, allDay);\r\n            cellDataValue.index = rowIndex * columnCount + columnIndex;\r\n            cellDataValue.isFirstGroupCell = this._isFirstGroupCell(rowIndex, columnIndex, options, rowCount, columnCount);\r\n            cellDataValue.isLastGroupCell = this._isLastGroupCell(rowIndex, columnIndex, options, rowCount, columnCount);\r\n            cellsRow.push(cellDataValue)\r\n        }\r\n        return cellsRow\r\n    }\r\n    getCellData(rowIndex, columnIndex, options, allDay) {\r\n        return allDay ? this.prepareAllDayCellData(options, rowIndex, columnIndex) : this.prepareCellData(options, rowIndex, columnIndex)\r\n    }\r\n    prepareCellData(options, rowIndex, columnIndex) {\r\n        var {\r\n            groups: groups,\r\n            startDayHour: startDayHour,\r\n            endDayHour: endDayHour,\r\n            interval: interval,\r\n            hoursInterval: hoursInterval\r\n        } = options;\r\n        var groupsList = getAllGroups(groups);\r\n        var startDate = this.getDateByCellIndices(options, rowIndex, columnIndex, this.getCellCountInDay(startDayHour, endDayHour, hoursInterval));\r\n        var endDate = this.calculateEndDate(startDate, interval, endDayHour);\r\n        var data = {\r\n            startDate: startDate,\r\n            endDate: endDate,\r\n            allDay: this.tableAllDay,\r\n            groupIndex: 0\r\n        };\r\n        if (groupsList.length > 0) {\r\n            data.groups = groupsList[0]\r\n        }\r\n        return data\r\n    }\r\n    prepareAllDayCellData(options, rowIndex, columnIndex) {\r\n        var data = this.prepareCellData(options, rowIndex, columnIndex);\r\n        var startDate = dateUtils.trimTime(data.startDate);\r\n        return _extends({}, data, {\r\n            startDate: startDate,\r\n            endDate: startDate,\r\n            allDay: true\r\n        })\r\n    }\r\n    getDateByCellIndices(options, rowIndex, columnIndex, cellCountInDay) {\r\n        var startViewDate = options.startViewDate;\r\n        var {\r\n            startDayHour: startDayHour,\r\n            interval: interval,\r\n            firstDayOfWeek: firstDayOfWeek,\r\n            intervalCount: intervalCount\r\n        } = options;\r\n        var isStartViewDateDuringDST = startViewDate.getHours() !== Math.floor(startDayHour);\r\n        if (isStartViewDateDuringDST) {\r\n            var dateWithCorrectHours = getStartViewDateWithoutDST(startViewDate, startDayHour);\r\n            startViewDate = new Date(dateWithCorrectHours - dateUtils.dateToMilliseconds(\"day\"))\r\n        }\r\n        var columnCountBase = this.getCellCount(options);\r\n        var rowCountBase = this.getRowCount(options);\r\n        var cellIndex = this._calculateCellIndex(rowIndex, columnIndex, rowCountBase, columnCountBase);\r\n        var millisecondsOffset = this.getMillisecondsOffset(cellIndex, interval, cellCountInDay);\r\n        var offsetByCount = this.isWorkView ? this.getTimeOffsetByColumnIndex(columnIndex, this.getFirstDayOfWeek(firstDayOfWeek), columnCountBase, intervalCount) : 0;\r\n        var startViewDateTime = startViewDate.getTime();\r\n        var currentDate = new Date(startViewDateTime + millisecondsOffset + offsetByCount);\r\n        var timeZoneDifference = isStartViewDateDuringDST ? 0 : dateUtils.getTimezonesDifference(startViewDate, currentDate);\r\n        currentDate.setTime(currentDate.getTime() + timeZoneDifference);\r\n        return currentDate\r\n    }\r\n    getMillisecondsOffset(cellIndex, interval, cellCountInDay) {\r\n        var dayIndex = Math.floor(cellIndex / cellCountInDay);\r\n        var realHiddenInterval = dayIndex * this.hiddenInterval;\r\n        return interval * cellIndex + realHiddenInterval\r\n    }\r\n    getTimeOffsetByColumnIndex(columnIndex, firstDayOfWeek, columnCount, intervalCount) {\r\n        var firstDayOfWeekDiff = Math.max(0, firstDayOfWeek - 1);\r\n        var columnsInWeek = columnCount / intervalCount;\r\n        var weekendCount = Math.floor((columnIndex + firstDayOfWeekDiff) / columnsInWeek);\r\n        return DAY_MS * weekendCount * 2\r\n    }\r\n    calculateEndDate(startDate, interval, endDayHour) {\r\n        var result = new Date(startDate);\r\n        result.setMilliseconds(result.getMilliseconds() + Math.round(interval));\r\n        return result\r\n    }\r\n    _calculateCellIndex(rowIndex, columnIndex, rowCount, columnCount) {\r\n        return calculateCellIndex(rowIndex, columnIndex, rowCount)\r\n    }\r\n    generateGroupedDataMap(viewDataMap) {\r\n        var {\r\n            allDayPanelMap: allDayPanelMap,\r\n            dateTableMap: dateTableMap\r\n        } = viewDataMap;\r\n        var {\r\n            previousGroupedDataMap: dateTableGroupedMap\r\n        } = dateTableMap.reduce((previousOptions, cellsRow) => {\r\n            var {\r\n                previousGroupedDataMap: previousGroupedDataMap,\r\n                previousRowIndex: previousRowIndex,\r\n                previousGroupIndex: previousGroupIndex\r\n            } = previousOptions;\r\n            var {\r\n                groupIndex: currentGroupIndex\r\n            } = cellsRow[0].cellData;\r\n            var currentRowIndex = currentGroupIndex === previousGroupIndex ? previousRowIndex + 1 : 0;\r\n            cellsRow.forEach(cell => {\r\n                var {\r\n                    groupIndex: groupIndex\r\n                } = cell.cellData;\r\n                if (!previousGroupedDataMap[groupIndex]) {\r\n                    previousGroupedDataMap[groupIndex] = []\r\n                }\r\n                if (!previousGroupedDataMap[groupIndex][currentRowIndex]) {\r\n                    previousGroupedDataMap[groupIndex][currentRowIndex] = []\r\n                }\r\n                previousGroupedDataMap[groupIndex][currentRowIndex].push(cell)\r\n            });\r\n            return {\r\n                previousGroupedDataMap: previousGroupedDataMap,\r\n                previousRowIndex: currentRowIndex,\r\n                previousGroupIndex: currentGroupIndex\r\n            }\r\n        }, {\r\n            previousGroupedDataMap: [],\r\n            previousRowIndex: -1,\r\n            previousGroupIndex: -1\r\n        });\r\n        var allDayPanelGroupedMap = [];\r\n        null === allDayPanelMap || void 0 === allDayPanelMap ? void 0 : allDayPanelMap.forEach(cell => {\r\n            var {\r\n                groupIndex: groupIndex\r\n            } = cell.cellData;\r\n            if (!allDayPanelGroupedMap[groupIndex]) {\r\n                allDayPanelGroupedMap[groupIndex] = []\r\n            }\r\n            allDayPanelGroupedMap[groupIndex].push(cell)\r\n        });\r\n        return {\r\n            allDayPanelGroupedMap: allDayPanelGroupedMap,\r\n            dateTableGroupedMap: dateTableGroupedMap\r\n        }\r\n    }\r\n    _isFirstGroupCell(rowIndex, columnIndex, options, rowCount, columnCount) {\r\n        var {\r\n            groupOrientation: groupOrientation,\r\n            groups: groups,\r\n            isGroupedByDate: isGroupedByDate\r\n        } = options;\r\n        var groupCount = getGroupCount(groups);\r\n        if (isGroupedByDate) {\r\n            return columnIndex % groupCount === 0\r\n        }\r\n        if (groupOrientation === HORIZONTAL_GROUP_ORIENTATION) {\r\n            return columnIndex % columnCount === 0\r\n        }\r\n        return rowIndex % rowCount === 0\r\n    }\r\n    _isLastGroupCell(rowIndex, columnIndex, options, rowCount, columnCount) {\r\n        var {\r\n            groupOrientation: groupOrientation,\r\n            groups: groups,\r\n            isGroupedByDate: isGroupedByDate\r\n        } = options;\r\n        var groupCount = getGroupCount(groups);\r\n        if (isGroupedByDate) {\r\n            return (columnIndex + 1) % groupCount === 0\r\n        }\r\n        if (groupOrientation === HORIZONTAL_GROUP_ORIENTATION) {\r\n            return (columnIndex + 1) % columnCount === 0\r\n        }\r\n        return (rowIndex + 1) % rowCount === 0\r\n    }\r\n    markSelectedAndFocusedCells(viewDataMap, renderOptions) {\r\n        var {\r\n            selectedCells: selectedCells,\r\n            focusedCell: focusedCell\r\n        } = renderOptions;\r\n        if (!selectedCells && !focusedCell) {\r\n            return viewDataMap\r\n        }\r\n        var {\r\n            allDayPanelMap: allDayPanelMap,\r\n            dateTableMap: dateTableMap\r\n        } = viewDataMap;\r\n        var nextDateTableMap = dateTableMap.map(row => this._markSelectedAndFocusedCellsInRow(row, selectedCells, focusedCell));\r\n        var nextAllDayMap = this._markSelectedAndFocusedCellsInRow(allDayPanelMap, selectedCells, focusedCell);\r\n        return {\r\n            allDayPanelMap: nextAllDayMap,\r\n            dateTableMap: nextDateTableMap\r\n        }\r\n    }\r\n    _markSelectedAndFocusedCellsInRow(dataRow, selectedCells, focusedCell) {\r\n        return dataRow.map(cell => {\r\n            var {\r\n                index: index,\r\n                groupIndex: groupIndex,\r\n                allDay: allDay,\r\n                startDate: startDate\r\n            } = cell.cellData;\r\n            var indexInSelectedCells = selectedCells.findIndex(_ref5 => {\r\n                var {\r\n                    index: selectedCellIndex,\r\n                    groupIndex: selectedCellGroupIndex,\r\n                    allDay: selectedCellAllDay,\r\n                    startDate: selectedCellStartDate\r\n                } = _ref5;\r\n                return groupIndex === selectedCellGroupIndex && (index === selectedCellIndex || void 0 === selectedCellIndex && startDate.getTime() === selectedCellStartDate.getTime()) && !!allDay === !!selectedCellAllDay\r\n            });\r\n            var isFocused = !!focusedCell && index === focusedCell.cellData.index && groupIndex === focusedCell.cellData.groupIndex && allDay === focusedCell.cellData.allDay;\r\n            if (!isFocused && -1 === indexInSelectedCells) {\r\n                return cell\r\n            }\r\n            return _extends({}, cell, {\r\n                cellData: _extends({}, cell.cellData, {\r\n                    isSelected: indexInSelectedCells > -1,\r\n                    isFocused: isFocused\r\n                })\r\n            })\r\n        })\r\n    }\r\n    getInterval(hoursInterval) {\r\n        return hoursInterval * HOUR_MS\r\n    }\r\n    _getIntervalDuration(intervalCount) {\r\n        return dateUtils.dateToMilliseconds(\"day\") * intervalCount\r\n    }\r\n    _setVisibilityDates() {}\r\n    getCellCountInDay(startDayHour, endDayHour, hoursInterval) {\r\n        var result = calculateDayDuration(startDayHour, endDayHour) / hoursInterval;\r\n        return Math.ceil(result)\r\n    }\r\n    getCellCount(options) {\r\n        var {\r\n            intervalCount: intervalCount,\r\n            viewType: viewType,\r\n            startDayHour: startDayHour,\r\n            endDayHour: endDayHour,\r\n            hoursInterval: hoursInterval\r\n        } = options;\r\n        var cellCountInDay = this.getCellCountInDay(startDayHour, endDayHour, hoursInterval);\r\n        var columnCountInDay = isHorizontalView(viewType) ? cellCountInDay : 1;\r\n        return this.daysInInterval * intervalCount * columnCountInDay\r\n    }\r\n    getRowCount(options) {\r\n        var {\r\n            viewType: viewType,\r\n            startDayHour: startDayHour,\r\n            endDayHour: endDayHour,\r\n            hoursInterval: hoursInterval\r\n        } = options;\r\n        var cellCountInDay = this.getCellCountInDay(startDayHour, endDayHour, hoursInterval);\r\n        var rowCountInDay = !isHorizontalView(viewType) ? cellCountInDay : 1;\r\n        return rowCountInDay\r\n    }\r\n    setHiddenInterval(startDayHour, endDayHour, hoursInterval) {\r\n        this.hiddenInterval = DAY_MS - this.getVisibleDayDuration(startDayHour, endDayHour, hoursInterval)\r\n    }\r\n    getVisibleDayDuration(startDayHour, endDayHour, hoursInterval) {\r\n        var cellCountInDay = this.getCellCountInDay(startDayHour, endDayHour, hoursInterval);\r\n        return hoursInterval * cellCountInDay * HOUR_MS\r\n    }\r\n    getFirstDayOfWeek(firstDayOfWeekOption) {\r\n        return firstDayOfWeekOption\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}